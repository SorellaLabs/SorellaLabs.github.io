<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Trust-DNS is intended to be a fully compliant domain name server and client library."><title>trust_dns_client - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e883e87179a81222.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="trust_dns_client" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (de686cbc6 2023-12-14)" data-channel="nightly" data-search-js="search-874d56868bf05518.js" data-settings-js="settings-fe03fdc259827cd2.js" ><script src="../static.files/storage-bc37acceda91d44a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-77dede896d6ac08e.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../trust_dns_client/index.html">trust_dns_client</a><span class="version">0.20.4</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">trust_dns_client</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/trust_dns_client/lib.rs.html#18-291">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Trust-DNS is intended to be a fully compliant domain name server and client library.</p>
<p>The Client library is responsible for the basic protocols responsible for communicating with DNS servers (authorities) and resolvers. It can be used for managing DNS records through the use of update operations. It is possible to send raw DNS Messages with the Client, but for ease of use the <code>query</code> and various other update operations are recommended for general use.</p>
<p>For a system-like resolver, see <a href="https://docs.rs/trust-dns-resolver">trust-dns-resolver</a>. This is most likely what you want if all you want to do is lookup IP addresses.</p>
<p>For serving DNS serving, see <a href="https://docs.rs/trust-dns-server">trust-dns-server</a>.</p>
<h2 id="goals"><a href="#goals">Goals</a></h2>
<ul>
<li>Only safe Rust</li>
<li>All errors handled</li>
<li>Simple to manage servers</li>
<li>High level abstraction for clients</li>
<li>Secure dynamic update</li>
<li>New features for securing public information</li>
</ul>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>This shows basic usage of the SyncClient. More examples will be associated directly with other types.</p>
<h3 id="dependency"><a href="#dependency">Dependency</a></h3><div class="example-wrap"><pre class="language-toml"><code>[dependencies]
trust-dns-client = &quot;*&quot;
</code></pre></div>
<p>By default DNSSec validation is built in with OpenSSL, this can be disabled with:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
trust-dns-client = { version = &quot;*&quot;, default-features = false }
</code></pre></div><h3 id="objects"><a href="#objects">Objects</a></h3>
<p>There are two variations of implementations of the Client. The <code>SyncClient</code>, a synchronous client, and the <code>AsyncClient</code>, a Tokio async client. <code>SyncClient</code> is an implementation of the <code>Client</code> trait, there is another implementation, <code>SyncDnssecClient</code>, which validates DNSSec records. For these basic examples we’ll only look at the <code>SyncClient</code></p>
<p>First we must decide on the type of connection, there are three supported by Trust-DNS today, UDP, TCP and TLS. TLS requires OpenSSL by default, see also <a href="https://docs.rs/trust-dns-native-tls">trust-dns-native-tls</a> and <a href="https://docs.rs/trust-dns-rustls">trust-dns-rustls</a> for other TLS options.</p>
<h3 id="setup-a-connection"><a href="#setup-a-connection">Setup a connection</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>trust_dns_proto::DnsStreamHandle;
<span class="kw">use </span>trust_dns_client::client::{Client, ClientConnection, SyncClient};
<span class="kw">use </span>trust_dns_client::udp::UdpClientConnection;

<span class="kw">let </span>address = <span class="string">"8.8.8.8:53"</span>.parse().unwrap();
<span class="kw">let </span>conn = UdpClientConnection::new(address).unwrap();

<span class="comment">// and then create the Client
</span><span class="kw">let </span>client = SyncClient::new(conn);</code></pre></div>
<p>At this point the client is ready to be used. See also <code>client::SyncDnssecClient</code> for DNSSec validation. The rest of these examples will assume that the above boilerplate has already been performed.</p>
<h3 id="querying"><a href="#querying">Querying</a></h3>
<p>Using the Client to query for DNS records is easy enough, though it performs no resolution. The <code>trust-dns-resolver</code> has a simpler interface if that’s what is desired. Over time that library will gain more features to generically query for different types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::net::Ipv4Addr;
<span class="kw">use </span>std::str::FromStr;
<span class="kw">use </span>trust_dns_client::op::DnsResponse;
<span class="kw">use </span>trust_dns_client::rr::{DNSClass, Name, RData, Record, RecordType};

<span class="comment">// Specify the name, note the final '.' which specifies it's an FQDN
</span><span class="kw">let </span>name = Name::from_str(<span class="string">"www.example.com."</span>).unwrap();

<span class="comment">// NOTE: see 'Setup a connection' example above
// Send the query and get a message response, see RecordType for all supported options
</span><span class="kw">let </span>response: DnsResponse = client.query(<span class="kw-2">&amp;</span>name, DNSClass::IN, RecordType::A).unwrap();

<span class="comment">// Messages are the packets sent between client and server in DNS.
//  there are many fields to a Message, DnsResponse can be dereferenced into
//  a Message. It's beyond the scope of these examples
//  to explain all the details of a Message. See trust_dns_client::op::message::Message for more details.
//  generally we will be interested in the Message::answers
</span><span class="kw">let </span>answers: <span class="kw-2">&amp;</span>[Record] = response.answers();

<span class="comment">// Records are generic objects which can contain any data.
//  In order to access it we need to first check what type of record it is
//  In this case we are interested in A, IPv4 address
</span><span class="kw">if let </span><span class="kw-2">&amp;</span>RData::A(<span class="kw-2">ref </span>ip) = answers[<span class="number">0</span>].rdata() {
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>ip, Ipv4Addr::new(<span class="number">93</span>, <span class="number">184</span>, <span class="number">216</span>, <span class="number">34</span>))
} <span class="kw">else </span>{
    <span class="macro">assert!</span>(<span class="bool-val">false</span>, <span class="string">"unexpected result"</span>)
}</code></pre></div>
<p>In the above example we successfully queried for a A record. There are many other types, each can be independently queried and the associated <code>trust_dns_client::rr::record_data::RData</code> has a variant with the deserialized data for the record stored.</p>
<h3 id="dynamic-update"><a href="#dynamic-update">Dynamic update</a></h3>
<p>Currently <code>trust-dns-client</code> supports SIG(0) signed records for authentication and authorization of dynamic DNS updates. It’s beyond the scope of these examples to show how to setup SIG(0) authorization on the server. <code>trust-dns-client</code> is known to work with BIND9 and <code>trust-dns-server</code>. Expect in the future for TLS to become a potentially better option for authorization with certificate chains. These examples show using SIG(0) for auth, requires OpenSSL. It’s beyond the scope of these examples to describe the configuration for the server.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::Read;
<span class="kw">use </span>std::net::Ipv4Addr;
<span class="kw">use </span>std::str::FromStr;

<span class="kw">use </span>time::Duration;
<span class="kw">use </span>openssl::rsa::Rsa;
<span class="kw">use </span>trust_dns_client::client::SyncClient;
<span class="kw">use </span>trust_dns_client::rr::{Name, RData, Record, RecordType};
<span class="kw">use </span>trust_dns_client::rr::dnssec::{Algorithm, Signer, KeyPair};
<span class="kw">use </span>trust_dns_client::op::ResponseCode;
<span class="kw">use </span>trust_dns_client::rr::rdata::key::KEY;


<span class="comment">// The format of the key is dependent on the KeyPair type, in this example we're using RSA
//  if the key was generated with BIND, the binary in Trust-DNS client lib `dnskey-to-pem`
//  can be used to convert this to a pem file
</span><span class="kw">let </span><span class="kw-2">mut </span>pem = File::open(<span class="string">"my_private_key.pem"</span>).unwrap();
<span class="kw">let </span><span class="kw-2">mut </span>pem_buf = Vec::&lt;u8&gt;::new();
pem.read_to_end(<span class="kw-2">&amp;mut </span>pem_buf).unwrap();

<span class="comment">// Create the RSA key
</span><span class="kw">let </span>rsa = Rsa::private_key_from_pem(<span class="kw-2">&amp;</span>pem_buf).unwrap();
<span class="kw">let </span>key = KeyPair::from_rsa(rsa).unwrap();

<span class="comment">// Create the RData KEY associated with the key. This example uses defaults for all the
//  KeyTrust, KeyUsage, UpdateScope, Protocol. Many of these have been deprecated in current
//  DNS RFCs, but are still supported by many servers for auth. See auth docs of the remote
//  server for help in understanding it's requirements and support of these options.
</span><span class="kw">let </span>sig0key = KEY::new(Default::default(),
                       Default::default(),
                       Default::default(),
                       Default::default(),
                       Algorithm::RSASHA256,
                       key.to_public_bytes().unwrap());

<span class="comment">// Create the Trust-DNS SIG(0) signing facility. Generally the signer_name is the label
//  associated with KEY record in the server.
</span><span class="kw">let </span>signer = Signer::sig0(sig0key,
                          key,
                          Name::from_str(<span class="string">"update.example.com."</span>).unwrap());

<span class="comment">// Create the DNS client, see above for creating the connection
</span><span class="kw">let </span>client = SyncClient::with_signer(conn, signer);

<span class="comment">// At this point we should have a client capable of sending signed SIG(0) records.

// Now we can send updates... let's create a new Record
</span><span class="kw">let </span><span class="kw-2">mut </span>record = Record::with(Name::from_str(<span class="string">"new.example.com"</span>).unwrap(),
                              RecordType::A,
                              Duration::minutes(<span class="number">5</span>).whole_seconds() <span class="kw">as </span>u32);
record.set_rdata(RData::A(Ipv4Addr::new(<span class="number">100</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">10</span>)));

<span class="comment">// the server must be authoritative for this zone
</span><span class="kw">let </span>origin = Name::from_str(<span class="string">"example.com."</span>).unwrap();

<span class="comment">// Create the record.
</span><span class="kw">let </span>result = client.create(record, origin).unwrap();
<span class="macro">assert_eq!</span>(result.response_code(), ResponseCode::NoError);</code></pre></div>
<p><em>Note</em>: The dynamic DNS functions defined by Trust-DNS are expressed as atomic operations, but this depends on support of the remote server. For example, the <code>create</code> operation shown above, should only succeed if there is no <code>RecordSet</code> of the specified type at the specified label. The other update operations are <code>append</code>, <code>compare_and_swap</code>, <code>delete_by_rdata</code>, <code>delete_rrset</code>, and <code>delete_all</code>. See the documentation for each of these methods on the <code>Client</code> trait.</p>
<h3 id="async-usage"><a href="#async-usage">Async usage</a></h3>
<p>The below example uses a single threaded tokio runtime example for the client. Tokio can get much more complex with multiple runtimes on many threads. This example is meant to show basic usage, the Tokio documentation should be reviewed for more advanced usage.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::net::{Ipv4Addr, SocketAddr};
<span class="kw">use </span>std::str::FromStr;
<span class="kw">use </span>tokio::net::UdpSocket;
<span class="kw">use </span>tokio::runtime::Runtime;

<span class="kw">use </span>trust_dns_client::udp::UdpClientStream;
<span class="kw">use </span>trust_dns_client::client::{Client, AsyncClient, ClientHandle};
<span class="kw">use </span>trust_dns_client::rr::{DNSClass, Name, RData, Record, RecordType};
<span class="kw">use </span>trust_dns_client::op::ResponseCode;
<span class="kw">use </span>trust_dns_client::rr::rdata::key::KEY;

<span class="comment">// We'll be using the current threads Tokio Runtime
</span><span class="kw">let </span><span class="kw-2">mut </span>runtime = Runtime::new().unwrap();

<span class="comment">// We need a connection, TCP and UDP are supported by DNS servers
//   (tcp construction is slightly different as it needs a multiplexer)
</span><span class="kw">let </span>stream = UdpClientStream::&lt;UdpSocket&gt;::new(([<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>], <span class="number">53</span>).into());

<span class="comment">// Create a new client, the bg is a background future which handles
//   the multiplexing of the DNS requests to the server.
//   the client is a handle to an unbounded queue for sending requests via the
//   background. The background must be scheduled to run before the client can
//   send any dns requests
</span><span class="kw">let </span>client = AsyncClient::connect(stream);

<span class="comment">// await the connection to be established
</span><span class="kw">let </span>(<span class="kw-2">mut </span>client, bg) = runtime.block_on(client).expect(<span class="string">"connection failed"</span>);

<span class="comment">// make sure to run the background task
</span>runtime.spawn(bg);

<span class="comment">// Create a query future
</span><span class="kw">let </span>query = client.query(Name::from_str(<span class="string">"www.example.com."</span>).unwrap(), DNSClass::IN, RecordType::A);

<span class="comment">// wait for its response
</span><span class="kw">let </span>response = runtime.block_on(query).unwrap();

<span class="comment">// validate it's what we expected
</span><span class="kw">if let </span><span class="kw-2">&amp;</span>RData::A(addr) = response.answers()[<span class="number">0</span>].rdata() {
    <span class="macro">assert_eq!</span>(addr, Ipv4Addr::new(<span class="number">93</span>, <span class="number">184</span>, <span class="number">216</span>, <span class="number">34</span>));
}</code></pre></div>
</div></details><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.proto"><code>pub use <a class="mod" href="../trust_dns_proto/index.html" title="mod trust_dns_proto">trust_dns_proto</a> as proto;</code></div></li></ul><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="client/index.html" title="mod trust_dns_client::client">client</a></div><div class="desc docblock-short">DNS Client associated classes for performing queries and other operations.</div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod trust_dns_client::error">error</a></div><div class="desc docblock-short">All defined errors for Trust-DNS</div></li><li><div class="item-name"><a class="mod" href="op/index.html" title="mod trust_dns_client::op">op</a></div><div class="desc docblock-short">Operations to send with a <code>Client</code> or server, e.g. <code>Query</code>, <code>Message</code>, or <code>UpdateMessage</code> can
be used together to either query or update resource records sets.</div></li><li><div class="item-name"><a class="mod" href="rr/index.html" title="mod trust_dns_client::rr">rr</a></div><div class="desc docblock-short">Resource record related components, e.g. <code>Name</code> aka label, <code>Record</code>, <code>RData</code>, …</div></li><li><div class="item-name"><a class="mod" href="serialize/index.html" title="mod trust_dns_client::serialize">serialize</a></div><div class="desc docblock-short">Contains serialization libraries for <code>binary</code> and text, <code>txt</code>.</div></li><li><div class="item-name"><a class="mod" href="tcp/index.html" title="mod trust_dns_client::tcp">tcp</a></div><div class="desc docblock-short">TCP protocol related components for DNS</div></li><li><div class="item-name"><a class="mod" href="udp/index.html" title="mod trust_dns_client::udp">udp</a></div><div class="desc docblock-short">UDP protocol related components for DNS</div></li></ul><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.version.html" title="fn trust_dns_client::version">version</a></div><div class="desc docblock-short">Returns a version as specified in Cargo.toml</div></li></ul></section></div></main></body></html>