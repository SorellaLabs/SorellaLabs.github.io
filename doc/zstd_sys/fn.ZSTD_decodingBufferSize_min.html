<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Buffer-less streaming decompression (synchronous mode)"><title>ZSTD_decodingBufferSize_min in zstd_sys - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e883e87179a81222.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zstd_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (de686cbc6 2023-12-14)" data-channel="nightly" data-search-js="search-874d56868bf05518.js" data-settings-js="settings-fe03fdc259827cd2.js" ><script src="../static.files/storage-bc37acceda91d44a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-77dede896d6ac08e.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../zstd_sys/index.html">zstd_sys</a><span class="version">2.0.9+zstd.1.5.5</span></h2></div><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">zstd_sys</a>::<wbr><a class="fn" href="#">ZSTD_decodingBufferSize_min</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/zstd_sys/bindings_zstd_experimental.rs.html#1471-1474">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn ZSTD_decodingBufferSize_min(
    windowSize: <a class="type" href="https://doc.rust-lang.org/nightly/core/ffi/type.c_ulonglong.html" title="type core::ffi::c_ulonglong">c_ulonglong</a>,
    frameContentSize: <a class="type" href="https://doc.rust-lang.org/nightly/core/ffi/type.c_ulonglong.html" title="type core::ffi::c_ulonglong">c_ulonglong</a>
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Buffer-less streaming decompression (synchronous mode)</p>
<p>A ZSTD_DCtx object is required to track streaming operations.
Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.
A ZSTD_DCtx object can be re-used multiple times.</p>
<p>First typical operation is to retrieve frame parameters, using ZSTD_getFrameHeader().
Frame header is extracted from the beginning of compressed frame, so providing only the frame’s beginning is enough.
Data fragment must be large enough to ensure successful decoding.
<code>ZSTD_frameHeaderSize_max</code> bytes is guaranteed to always be large enough.
result  : 0 : successful decoding, the <code>ZSTD_frameHeader</code> structure is correctly filled.
&gt;0 : <code>srcSize</code> is too small, please provide at least result bytes on next attempt.
errorCode, which can be tested using ZSTD_isError().</p>
<p>It fills a ZSTD_frameHeader structure with important information to correctly decode the frame,
such as the dictionary ID, content size, or maximum back-reference distance (<code>windowSize</code>).
Note that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information.
As a consequence, check that values remain within valid application range.
For example, do not allocate memory blindly, check that <code>windowSize</code> is within expectation.
Each application can set its own limits, depending on local restrictions.
For extended interoperability, it is recommended to support <code>windowSize</code> of at least 8 MB.</p>
<p>ZSTD_decompressContinue() needs previous data blocks during decompression, up to <code>windowSize</code> bytes.
ZSTD_decompressContinue() is very sensitive to contiguity,
if 2 blocks don’t follow each other, make sure that either the compressor breaks contiguity at the same place,
or that previous contiguous segment is large enough to properly handle maximum back-reference distance.
There are multiple ways to guarantee this condition.</p>
<p>The most memory efficient way is to use a round buffer of sufficient size.
Sufficient size is determined by invoking ZSTD_decodingBufferSize_min(),
which can return an error code if required value is too large for current system (in 32-bits mode).
In a round buffer methodology, ZSTD_decompressContinue() decompresses each block next to previous one,
up to the moment there is not enough room left in the buffer to guarantee decoding another full block,
which maximum size is provided in <code>ZSTD_frameHeader</code> structure, field <code>blockSizeMax</code>.
At which point, decoding can resume from the beginning of the buffer.
Note that already decoded data stored in the buffer should be flushed before being overwritten.</p>
<p>There are alternatives possible, for example using two or more buffers of size <code>windowSize</code> each, though they consume more memory.</p>
<p>Finally, if you control the compression process, you can also ignore all buffer size rules,
as long as the encoder and decoder progress in “lock-step”,
aka use exactly the same buffer sizes, break contiguity at the same place, etc.</p>
<p>Once buffers are setup, start decompression, with ZSTD_decompressBegin().
If decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().</p>
<p>Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.
ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as ‘srcSize’ to ZSTD_decompressContinue().
ZSTD_decompressContinue() requires this <em>exact</em> amount of bytes, or it will fail.</p>
<p>result of ZSTD_decompressContinue() is the number of bytes regenerated within ‘dst’ (necessarily &lt;= dstCapacity).
It can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.
It can also be an error code, which can be tested with ZSTD_isError().</p>
<p>A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.
Context can then be reset to start a new decompression.</p>
<p>Note : it’s possible to know if next input to present is a header or a block, using ZSTD_nextInputType().
This information is not required to properly decode a frame.</p>
<p>== Special case : skippable frames ==</p>
<p>Skippable frames allow integration of user-defined data into a flow of concatenated frames.
Skippable frames will be ignored (skipped) by decompressor.
The format of skippable frames is as follows :
a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F
b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits
c) Frame Content - any content (User Data) of length equal to Frame Size
For skippable frames ZSTD_getFrameHeader() returns zfhPtr-&gt;frameType==ZSTD_skippableFrame.
For skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content.</p>
</div></details></section></div></main></body></html>