<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Generate types that implement `alloy-sol-types` traits, which can be used for type-safe ABI and EIP-712 serialization to interface with Ethereum smart contracts."><title>sol in alloy_sol_macro - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e883e87179a81222.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="alloy_sol_macro" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (de686cbc6 2023-12-14)" data-channel="nightly" data-search-js="search-874d56868bf05518.js" data-settings-js="settings-fe03fdc259827cd2.js" ><script src="../static.files/storage-bc37acceda91d44a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-77dede896d6ac08e.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/alloy-rs/core/main/assets/favicon.ico"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../alloy_sol_macro/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../alloy_sol_macro/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt="logo"></a><h2><a href="../alloy_sol_macro/index.html">alloy_sol_macro</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">alloy_sol_macro</a>::<wbr><a class="macro" href="#">sol</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/alloy_sol_macro/lib.rs.html#202">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>sol!() { <span class="comment">/* proc-macro */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Generate types that implement <a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a> traits, which can be used
for type-safe <a href="https://docs.soliditylang.org/en/latest/abi-spec.html">ABI</a> and <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a> serialization to interface with Ethereum
smart contracts.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<blockquote>
<p>Note: the following example code blocks cannot be tested here because the
generated code references <a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a>, so they are <a href="https://github.com/alloy-rs/core/tree/main/crates/sol-types/tests/doctests">tested in that
crate</a> and included with <a href="https://doc.rust-lang.org/nightly/core/macro.include_str.html" title="macro core::include_str"><code>include_str!</code></a> in this doc instead.</p>
</blockquote>
<p>There are two main ways to use this macro:</p>
<ul>
<li>you can <a href="#solidity">write Solidity code</a>, or provide a path to a Solidity file,</li>
<li>if you enable the <code>json</code> feature, you can provide <a href="#json-abi">an ABI, or a path to one, in JSON
format</a>.</li>
</ul>
<p>Note:</p>
<ul>
<li>relative file system paths are rooted at the <code>CARGO_MANIFEST_DIR</code> environment variable</li>
<li>no casing convention is enforced for any identifier,</li>
<li>unnamed arguments will be given a name based on their index in the list, e.g. <code>_0</code>, <code>_1</code>…</li>
<li>a current limitation for certain items is that custom types, like structs, must be defined in
the same macro scope, otherwise a signature cannot be generated at compile time. You can bring
them in scope with a <a href="#udvt-and-type-aliases">Solidity type alias</a>.</li>
</ul>
<h3 id="solidity"><a href="#solidity">Solidity</a></h3>
<p>This macro uses <a href="../syn_solidity/index.html" title="mod syn_solidity"><code>syn-solidity</code></a> to parse Solidity-like syntax. See
<a href="../syn_solidity/index.html" title="mod syn_solidity">its documentation</a> for more.</p>
<p>Solidity input can be either one of the following:</p>
<ul>
<li>a Solidity item, which is a <a href="https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.sourceUnit">Solidity source unit</a> which generates one or more Rust
items,</li>
<li>a <a href="https://docs.soliditylang.org/en/latest/types.html">Solidity type name</a>, which simply expands to the corresponding Rust type.</li>
</ul>
<h4 id="attributes"><a href="#attributes">Attributes</a></h4>
<p>Inner attributes (<code>#![...]</code>) are parsed at the top of the input, just like a
Rust module. These can only be <code>sol</code> attributes, and they will apply to the
entire input.</p>
<p>Outer attributes (<code>#[...]</code>) are parsed as part of each individual item, like
structs, enums, etc. These can be any Rust attribute, and they will be added
to every Rust item generated from the Solidity item.</p>
<p>This macro provides the <code>sol</code> attribute, which can be used to customize the
generated code. Note that unused attributes are currently silently ignored,
but this may change in the future.</p>
<p>List of all <code>#[sol(...)]</code> supported attributes:</p>
<ul>
<li><code>all_derives [ = &lt;bool = false&gt;]</code>: adds all possible <code>#[derive(...)]</code> attributes to all
generated types. May significantly increase compile times due to all the extra generated code.
This is the default behaviour of <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen</code></a></li>
<li><code>extra_methods [ = &lt;bool = false&gt;]</code>: adds extra implementations and methods to all applicable
generated types, such as <code>From</code> impls and <code>as_&lt;variant&gt;</code> methods. May significantly increase
compile times due to all the extra generated code. This is the default behaviour of
<a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen</code></a></li>
<li><code>docs [ = &lt;bool = true&gt;]</code>: adds doc comments to all generated types. This is the default
behaviour of <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen</code></a></li>
<li><code>abi [ = &lt;bool = false&gt;]</code>: generates functions which return the dynamic ABI representation
(provided by <a href="https://docs.rs/alloy-json-abi"><code>alloy_json_abi</code></a>) of all the generated items.
Requires the <code>&quot;json&quot;</code> feature. For:
<ul>
<li>contracts: generates an <code>abi</code> module nested inside of the contract module, which contains:
<ul>
<li><code>pub fn contract() -&gt; JsonAbi</code>,</li>
<li><code>pub fn constructor() -&gt; Option&lt;Constructor&gt;</code></li>
<li><code>pub fn fallback() -&gt; Option&lt;Fallback&gt;</code></li>
<li><code>pub fn receive() -&gt; Option&lt;Receive&gt;</code></li>
<li><code>pub fn functions() -&gt; BTreeMap&lt;String, Vec&lt;Function&gt;&gt;</code></li>
<li><code>pub fn events() -&gt; BTreeMap&lt;String, Vec&lt;Event&gt;&gt;</code></li>
<li><code>pub fn errors() -&gt; BTreeMap&lt;String, Vec&lt;Error&gt;&gt;</code></li>
</ul>
</li>
<li>items: generates implementations of the <code>SolAbiExt</code> trait, alongside the existing
<a href="https://docs.rs/alloy-sol-types"><code>alloy-sol-types</code></a> traits</li>
</ul>
</li>
<li><code>bytecode = &lt;hex string literal&gt;</code>: specifies the creation/init bytecode of a contract. This
will emit a <code>static</code> item with the specified bytes.</li>
<li><code>deployed_bytecode = &lt;hex string literal&gt;</code>: specifies the deployed bytecode of a contract.
This will emit a <code>static</code> item with the specified bytes.</li>
<li><code>type_check = &lt;string literal&gt;</code>: specifies a function to be used to check an User Defined
Type.</li>
</ul>
<h4 id="structs-and-enums"><a href="#structs-and-enums">Structs and enums</a></h4>
<p>Structs and enums generate their corresponding Rust types. Enums are
additionally annotated with <code>#[repr(u8)]</code>, and as such can have a maximum of
256 variants.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::{hex, Address, U256};
<span class="kw">use </span>alloy_sol_types::{sol, SolEnum, SolType};

<span class="macro">sol! </span>{
   <span class="kw">struct </span>Foo {
       uint256 bar;
       address[] baz;
   }

   <span class="doccomment">/// Nested struct.
   </span><span class="kw">struct </span>Nested {
       Foo[<span class="number">2</span>] a;
       address b;
   }

   <span class="kw">enum </span>Enum {
       A,
       B,
       C,
   }
}

<span class="attr">#[test]
</span><span class="kw">fn </span>structs() {
   <span class="kw">let </span>my_foo = Foo {
       bar: U256::from(<span class="number">42</span>),
       baz: <span class="macro">vec!</span>[Address::repeat_byte(<span class="number">0x11</span>), Address::repeat_byte(<span class="number">0x22</span>)],
   };

   <span class="kw">let </span>_nested = Nested { a: [my_foo.clone(), my_foo.clone()], b: Address::ZERO };

   <span class="kw">let </span>abi_encoded = Foo::abi_encode_sequence(<span class="kw-2">&amp;</span>my_foo);
   <span class="macro">assert_eq!</span>(
       abi_encoded,
       <span class="macro">hex! </span>{
           <span class="string">"000000000000000000000000000000000000000000000000000000000000002a" </span><span class="comment">// bar
           </span><span class="string">"0000000000000000000000000000000000000000000000000000000000000040" </span><span class="comment">// baz offset
           </span><span class="string">"0000000000000000000000000000000000000000000000000000000000000002" </span><span class="comment">// baz length
           </span><span class="string">"0000000000000000000000001111111111111111111111111111111111111111" </span><span class="comment">// baz[0]
           </span><span class="string">"0000000000000000000000002222222222222222222222222222222222222222" </span><span class="comment">// baz[1]
       </span>}
   );

   <span class="kw">let </span>abi_encoded_enum = Enum::B.abi_encode();
   <span class="macro">assert_eq!</span>(
       abi_encoded_enum,
       <span class="macro">hex! </span>{
           <span class="string">"0000000000000000000000000000000000000000000000000000000000000001"
       </span>}
   );
}</code></pre></div>
<h4 id="udvt-and-type-aliases"><a href="#udvt-and-type-aliases">UDVT and type aliases</a></h4>
<p>User defined value types (UDVT) generate a tuple struct with the type as
its only field, and type aliases simply expand to the corresponding Rust
type.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::Address;
<span class="kw">use </span>alloy_sol_types::{sol, SolType};

<span class="comment">// Type definition: generates a new struct that implements `SolType`
</span><span class="macro">sol! </span>{
   <span class="kw">type </span>MyType is uint256;
}

<span class="comment">// Type aliases
</span><span class="kw">type </span>B32 = <span class="macro">sol! </span>{ bytes32 };
<span class="comment">// This is equivalent to the following:
// type B32 = alloy_sol_types::sol_data::Bytes&lt;32&gt;;

</span><span class="kw">type </span>SolArrayOf&lt;T&gt; = <span class="macro">sol! </span>{ T[] };
<span class="kw">type </span>SolTuple = <span class="macro">sol! </span>{ tuple(address, bytes, string) };

<span class="attr">#[test]
</span><span class="kw">fn </span>types() {
   <span class="kw">let _ </span>= &lt;<span class="macro">sol!</span>(bool)&gt;::abi_encode(<span class="kw-2">&amp;</span><span class="bool-val">true</span>);
   <span class="kw">let _ </span>= B32::abi_encode(<span class="kw-2">&amp;</span>[<span class="number">0</span>; <span class="number">32</span>]);
   <span class="kw">let _ </span>= SolArrayOf::&lt;<span class="macro">sol!</span>(bool)&gt;::abi_encode(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="bool-val">true</span>, <span class="bool-val">false</span>]);
   <span class="kw">let _ </span>= SolTuple::abi_encode(<span class="kw-2">&amp;</span>(Address::ZERO, <span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">32</span>], <span class="string">"hello"</span>.to_string()));
}</code></pre></div>
<h4 id="functions-and-errors"><a href="#functions-and-errors">Functions and errors</a></h4>
<p>Functions generate two structs that implement <code>SolCall</code>: <code>&lt;name&gt;Call</code> for
the function arguments, and <code>&lt;name&gt;Return</code> for the return values.</p>
<p>In the case of overloaded functions, an underscore and the index of the
function will be appended to <code>&lt;name&gt;</code> (like <code>foo_0</code>, <code>foo_1</code>…) for
disambiguation, but the signature will remain the same.</p>
<p>E.g. if there are two functions named <code>foo</code>, the generated types will be
<code>foo_0Call</code> and <code>foo_1Call</code>, each of which will implement <code>SolCall</code>
with their respective signatures.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::{hex, keccak256, U256};
<span class="kw">use </span>alloy_sol_types::{sol, SolCall, SolError};

<span class="macro">sol! </span>{
   function foo(uint256 a, uint256 b) external view returns (uint256);

   <span class="comment">// These will generate structs prefixed with `overloaded_0`, `overloaded_1`,
   // and `overloaded_2` by default, but each signature is calculated with
   // `overloaded` as the function name.
   </span>function overloaded();
   function overloaded(uint256) returns (uint256);
   function overloaded(string);

   <span class="doccomment">/// Implements [`SolError`].
   </span><span class="attr">#[derive(Debug, PartialEq, Eq)]
   </span>error MyError(uint256 a, uint256 b);
}

<span class="attr">#[test]
</span><span class="kw">fn </span>function() {
   assert_call_signature::&lt;fooCall&gt;(<span class="string">"foo(uint256,uint256)"</span>);

   <span class="kw">let </span>call = fooCall { a: U256::from(<span class="number">1</span>), b: U256::from(<span class="number">2</span>) };
   <span class="kw">let </span>_call_data = call.abi_encode();

   <span class="comment">// the signatures are unaffected
   </span><span class="kw">let _ </span>= overloaded_0Call {};
   assert_call_signature::&lt;overloaded_0Call&gt;(<span class="string">"overloaded()"</span>);

   <span class="kw">let _ </span>= overloaded_1Call { _0: U256::from(<span class="number">1</span>) };
   assert_call_signature::&lt;overloaded_1Call&gt;(<span class="string">"overloaded(uint256)"</span>);

   <span class="kw">let _ </span>= overloaded_2Call { _0: <span class="string">"hello"</span>.into() };
   assert_call_signature::&lt;overloaded_2Call&gt;(<span class="string">"overloaded(string)"</span>);
}

<span class="attr">#[test]
</span><span class="kw">fn </span>error() {
   assert_error_signature::&lt;MyError&gt;(<span class="string">"MyError(uint256,uint256)"</span>);
   <span class="kw">let </span>call_data = <span class="macro">hex!</span>(
       <span class="string">"0000000000000000000000000000000000000000000000000000000000000001"
       "0000000000000000000000000000000000000000000000000000000000000002"
   </span>);
   <span class="macro">assert_eq!</span>(
       MyError::abi_decode_raw(<span class="kw-2">&amp;</span>call_data, <span class="bool-val">true</span>),
       <span class="prelude-val">Ok</span>(MyError { a: U256::from(<span class="number">1</span>), b: U256::from(<span class="number">2</span>) })
   );
}

<span class="kw">fn </span>assert_call_signature&lt;T: SolCall&gt;(expected: <span class="kw-2">&amp;</span>str) {
   <span class="macro">assert_eq!</span>(T::SIGNATURE, expected);
   <span class="macro">assert_eq!</span>(T::SELECTOR, keccak256(expected)[..<span class="number">4</span>]);
}

<span class="kw">fn </span>assert_error_signature&lt;T: SolError&gt;(expected: <span class="kw-2">&amp;</span>str) {
   <span class="macro">assert_eq!</span>(T::SIGNATURE, expected);
   <span class="macro">assert_eq!</span>(T::SELECTOR, keccak256(expected)[..<span class="number">4</span>]);
}</code></pre></div>
<h4 id="events"><a href="#events">Events</a></h4>
<p>Events generate a struct that implements <code>SolEvent</code>.</p>
<p>Note that events have special encoding rules in Solidity. For example,
<code>string indexed</code> will be encoded in the topics as its <code>bytes32</code> Keccak-256
hash, and as such the generated field for this argument will be <code>bytes32</code>,
and not <code>string</code>.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#![allow(clippy::assertions_on_constants)]

</span><span class="kw">use </span>alloy_primitives::{hex, keccak256, B256, U256};
<span class="kw">use </span>alloy_sol_types::{abi::token::WordToken, sol, SolEvent};

<span class="macro">sol! </span>{
   <span class="attr">#[derive(Default)]
   </span>event MyEvent(bytes32 indexed a, uint256 b, string indexed c, bytes d);

   event LogNote(
       bytes4   indexed  sig,
       address  indexed  guy,
       bytes32  indexed  foo,
       bytes32  indexed  bar,
       uint              wad,
       bytes             fax
   ) anonymous;

   <span class="kw">struct </span>Data {
       bytes data;
   }
   event MyEvent2(Data indexed data);
}

<span class="attr">#[test]
</span><span class="kw">fn </span>event() {
   assert_event_signature::&lt;MyEvent&gt;(<span class="string">"MyEvent(bytes32,uint256,string,bytes)"</span>);
   <span class="macro">assert!</span>(!MyEvent::ANONYMOUS);
   <span class="kw">let </span>event = MyEvent {
       a: [<span class="number">0x11</span>; <span class="number">32</span>].into(),
       b: U256::from(<span class="number">1u64</span>),
       c: keccak256(<span class="string">"Hello World"</span>),
       d: Vec::new(),
   };
   <span class="comment">// topics are `(SELECTOR, a, keccak256(c))`
   </span><span class="macro">assert_eq!</span>(
       event.encode_topics_array::&lt;<span class="number">3</span>&gt;(),
       [
           WordToken(MyEvent::SIGNATURE_HASH),
           WordToken(B256::repeat_byte(<span class="number">0x11</span>)),
           WordToken(keccak256(<span class="string">"Hello World"</span>))
       ]
   );
   <span class="comment">// dynamic data is `abi.abi_encode(b, d)`
   </span><span class="macro">assert_eq!</span>(
       event.encode_data(),
       <span class="macro">hex!</span>(
           <span class="comment">// b
           </span><span class="string">"0000000000000000000000000000000000000000000000000000000000000001"
           </span><span class="comment">// d offset
           </span><span class="string">"0000000000000000000000000000000000000000000000000000000000000040"
           </span><span class="comment">// d length
           </span><span class="string">"0000000000000000000000000000000000000000000000000000000000000000"
       </span>),
   );

   assert_event_signature::&lt;LogNote&gt;(<span class="string">"LogNote(bytes4,address,bytes32,bytes32,uint256,bytes)"</span>);
   <span class="macro">assert!</span>(LogNote::ANONYMOUS);

   assert_event_signature::&lt;MyEvent2&gt;(<span class="string">"MyEvent2((bytes))"</span>);
   <span class="macro">assert!</span>(!MyEvent2::ANONYMOUS);
}

<span class="kw">fn </span>assert_event_signature&lt;T: SolEvent&gt;(expected: <span class="kw-2">&amp;</span>str) {
   <span class="macro">assert_eq!</span>(T::SIGNATURE, expected);
   <span class="macro">assert_eq!</span>(T::SIGNATURE_HASH, keccak256(expected));
}</code></pre></div>
<h4 id="contractsinterfaces"><a href="#contractsinterfaces">Contracts/interfaces</a></h4>
<p>Contracts generate a module with the same name, which contains all the items.
This module will also contain 3 container enums which implement
<code>SolInterface</code>, one for each:</p>
<ul>
<li>functions: <code>&lt;contract_name&gt;Calls</code></li>
<li>errors: <code>&lt;contract_name&gt;Errors</code></li>
<li>events: <code>&lt;contract_name&gt;Events</code></li>
</ul>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_primitives::{address, hex, U256};
<span class="kw">use </span>alloy_sol_types::{sol, SolCall, SolInterface};

<span class="macro">sol! </span>{
   <span class="doccomment">/// Interface of the ERC20 standard as defined in [the EIP].
   ///
   /// [the EIP]: https://eips.ethereum.org/EIPS/eip-20
   </span><span class="attr">#[derive(Debug, PartialEq, Eq)]
   </span>interface IERC20 {
       event Transfer(address indexed from, address indexed to, uint256 value);
       event Approval(address indexed owner, address indexed spender, uint256 value);

       function totalSupply() external view returns (uint256);
       function balanceOf(address account) external view returns (uint256);
       function transfer(address to, uint256 amount) external returns (bool);
       function allowance(address owner, address spender) external view returns (uint256);
       function approve(address spender, uint256 amount) external returns (bool);
       function transferFrom(address from, address to, uint256 amount) external returns (bool);
   }
}

<span class="attr">#[test]
</span><span class="kw">fn </span>contracts() {
   <span class="comment">// random mainnet ERC20 transfer
   // https://etherscan.io/tx/0x947332ff624b5092fb92e8f02cdbb8a50314e861a4b39c29a286b3b75432165e
   </span><span class="kw">let </span>data = <span class="macro">hex!</span>(
       <span class="string">"a9059cbb"
       "0000000000000000000000008bc47be1e3abbaba182069c89d08a61fa6c2b292"
       "0000000000000000000000000000000000000000000000000000000253c51700"
   </span>);
   <span class="kw">let </span>expected = IERC20::transferCall {
       to: <span class="macro">address!</span>(<span class="string">"8bc47be1e3abbaba182069c89d08a61fa6c2b292"</span>),
       amount: U256::from(<span class="number">9995360000_u64</span>),
   };

   <span class="macro">assert_eq!</span>(data[..<span class="number">4</span>], IERC20::transferCall::SELECTOR);
   <span class="kw">let </span>decoded = IERC20::IERC20Calls::abi_decode(<span class="kw-2">&amp;</span>data, <span class="bool-val">true</span>).unwrap();
   <span class="macro">assert_eq!</span>(decoded, IERC20::IERC20Calls::transfer(expected));
   <span class="macro">assert_eq!</span>(decoded.abi_encode(), data);
}</code></pre></div>
<h3 id="json-abi"><a href="#json-abi">JSON ABI</a></h3>
<p>Contracts can also be generated from ABI JSON strings and files, similar to
the <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html">ethers-rs <code>abigen!</code> macro</a>.</p>
<p>JSON objects containing the <code>abi</code>, <code>evm</code>, <code>bytecode</code>, <code>deployedBytecode</code>,
and similar keys are also supported.</p>
<p>Note that only valid JSON is supported, and not the human-readable ABI
format, also used by <a href="https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html"><code>abigen!</code></a>. This should instead be easily converted to
<a href="#solidity">normal Solidity input</a>.</p>
<p>Prefer using <a href="#solidity">Solidity input</a> when possible, as the JSON ABI
format omits some information which is useful to this macro, such as enum
variants and visibility modifiers on functions.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloy_sol_types::{sol, SolCall};

<span class="macro">sol!</span>(
   MyJsonContract1,
   <span class="string">r#"[
       {
           "inputs": [
               { "name": "bar", "type": "uint256" },
               { 
                   "internalType": "struct MyJsonContract.MyStruct",
                   "name": "baz",
                   "type": "tuple",
                   "components": [
                       { "name": "a", "type": "bool[]" },
                       { "name": "b", "type": "bytes18[][]" }
                   ]
               }
           ],
           "outputs": [],
           "stateMutability": "view",
           "name": "foo",
           "type": "function"
       }
   ]"#
</span>);

<span class="comment">// This is the same as:
</span><span class="macro">sol! </span>{
   interface MyJsonContract2 {
       <span class="kw">struct </span>MyStruct {
           bool[] a;
           bytes18[][] b;
       }

       function foo(uint256 bar, MyStruct baz) external view;
   }
}

<span class="attr">#[test]
</span><span class="kw">fn </span>abigen() {
   <span class="macro">assert_eq!</span>(MyJsonContract1::fooCall::SIGNATURE, MyJsonContract2::fooCall::SIGNATURE,);
}</code></pre></div>
</div></details></section></div></main></body></html>