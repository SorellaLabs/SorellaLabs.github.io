<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/Users/user/.cargo/registry/src/index.crates.io-6f17d22bba15001f/zstd-sys-2.0.9+zstd.1.5.5/src/bindings_zstd_experimental.rs`."><title>bindings_zstd_experimental.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="zstd_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-nightly (b11fbfbf3 2024-02-03)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title">
            <h2>Files</h2></div></nav><div class="sidebar-resizer"></div>
    <main><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../zstd_sys/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
<a href="#531" id="531">531</a>
<a href="#532" id="532">532</a>
<a href="#533" id="533">533</a>
<a href="#534" id="534">534</a>
<a href="#535" id="535">535</a>
<a href="#536" id="536">536</a>
<a href="#537" id="537">537</a>
<a href="#538" id="538">538</a>
<a href="#539" id="539">539</a>
<a href="#540" id="540">540</a>
<a href="#541" id="541">541</a>
<a href="#542" id="542">542</a>
<a href="#543" id="543">543</a>
<a href="#544" id="544">544</a>
<a href="#545" id="545">545</a>
<a href="#546" id="546">546</a>
<a href="#547" id="547">547</a>
<a href="#548" id="548">548</a>
<a href="#549" id="549">549</a>
<a href="#550" id="550">550</a>
<a href="#551" id="551">551</a>
<a href="#552" id="552">552</a>
<a href="#553" id="553">553</a>
<a href="#554" id="554">554</a>
<a href="#555" id="555">555</a>
<a href="#556" id="556">556</a>
<a href="#557" id="557">557</a>
<a href="#558" id="558">558</a>
<a href="#559" id="559">559</a>
<a href="#560" id="560">560</a>
<a href="#561" id="561">561</a>
<a href="#562" id="562">562</a>
<a href="#563" id="563">563</a>
<a href="#564" id="564">564</a>
<a href="#565" id="565">565</a>
<a href="#566" id="566">566</a>
<a href="#567" id="567">567</a>
<a href="#568" id="568">568</a>
<a href="#569" id="569">569</a>
<a href="#570" id="570">570</a>
<a href="#571" id="571">571</a>
<a href="#572" id="572">572</a>
<a href="#573" id="573">573</a>
<a href="#574" id="574">574</a>
<a href="#575" id="575">575</a>
<a href="#576" id="576">576</a>
<a href="#577" id="577">577</a>
<a href="#578" id="578">578</a>
<a href="#579" id="579">579</a>
<a href="#580" id="580">580</a>
<a href="#581" id="581">581</a>
<a href="#582" id="582">582</a>
<a href="#583" id="583">583</a>
<a href="#584" id="584">584</a>
<a href="#585" id="585">585</a>
<a href="#586" id="586">586</a>
<a href="#587" id="587">587</a>
<a href="#588" id="588">588</a>
<a href="#589" id="589">589</a>
<a href="#590" id="590">590</a>
<a href="#591" id="591">591</a>
<a href="#592" id="592">592</a>
<a href="#593" id="593">593</a>
<a href="#594" id="594">594</a>
<a href="#595" id="595">595</a>
<a href="#596" id="596">596</a>
<a href="#597" id="597">597</a>
<a href="#598" id="598">598</a>
<a href="#599" id="599">599</a>
<a href="#600" id="600">600</a>
<a href="#601" id="601">601</a>
<a href="#602" id="602">602</a>
<a href="#603" id="603">603</a>
<a href="#604" id="604">604</a>
<a href="#605" id="605">605</a>
<a href="#606" id="606">606</a>
<a href="#607" id="607">607</a>
<a href="#608" id="608">608</a>
<a href="#609" id="609">609</a>
<a href="#610" id="610">610</a>
<a href="#611" id="611">611</a>
<a href="#612" id="612">612</a>
<a href="#613" id="613">613</a>
<a href="#614" id="614">614</a>
<a href="#615" id="615">615</a>
<a href="#616" id="616">616</a>
<a href="#617" id="617">617</a>
<a href="#618" id="618">618</a>
<a href="#619" id="619">619</a>
<a href="#620" id="620">620</a>
<a href="#621" id="621">621</a>
<a href="#622" id="622">622</a>
<a href="#623" id="623">623</a>
<a href="#624" id="624">624</a>
<a href="#625" id="625">625</a>
<a href="#626" id="626">626</a>
<a href="#627" id="627">627</a>
<a href="#628" id="628">628</a>
<a href="#629" id="629">629</a>
<a href="#630" id="630">630</a>
<a href="#631" id="631">631</a>
<a href="#632" id="632">632</a>
<a href="#633" id="633">633</a>
<a href="#634" id="634">634</a>
<a href="#635" id="635">635</a>
<a href="#636" id="636">636</a>
<a href="#637" id="637">637</a>
<a href="#638" id="638">638</a>
<a href="#639" id="639">639</a>
<a href="#640" id="640">640</a>
<a href="#641" id="641">641</a>
<a href="#642" id="642">642</a>
<a href="#643" id="643">643</a>
<a href="#644" id="644">644</a>
<a href="#645" id="645">645</a>
<a href="#646" id="646">646</a>
<a href="#647" id="647">647</a>
<a href="#648" id="648">648</a>
<a href="#649" id="649">649</a>
<a href="#650" id="650">650</a>
<a href="#651" id="651">651</a>
<a href="#652" id="652">652</a>
<a href="#653" id="653">653</a>
<a href="#654" id="654">654</a>
<a href="#655" id="655">655</a>
<a href="#656" id="656">656</a>
<a href="#657" id="657">657</a>
<a href="#658" id="658">658</a>
<a href="#659" id="659">659</a>
<a href="#660" id="660">660</a>
<a href="#661" id="661">661</a>
<a href="#662" id="662">662</a>
<a href="#663" id="663">663</a>
<a href="#664" id="664">664</a>
<a href="#665" id="665">665</a>
<a href="#666" id="666">666</a>
<a href="#667" id="667">667</a>
<a href="#668" id="668">668</a>
<a href="#669" id="669">669</a>
<a href="#670" id="670">670</a>
<a href="#671" id="671">671</a>
<a href="#672" id="672">672</a>
<a href="#673" id="673">673</a>
<a href="#674" id="674">674</a>
<a href="#675" id="675">675</a>
<a href="#676" id="676">676</a>
<a href="#677" id="677">677</a>
<a href="#678" id="678">678</a>
<a href="#679" id="679">679</a>
<a href="#680" id="680">680</a>
<a href="#681" id="681">681</a>
<a href="#682" id="682">682</a>
<a href="#683" id="683">683</a>
<a href="#684" id="684">684</a>
<a href="#685" id="685">685</a>
<a href="#686" id="686">686</a>
<a href="#687" id="687">687</a>
<a href="#688" id="688">688</a>
<a href="#689" id="689">689</a>
<a href="#690" id="690">690</a>
<a href="#691" id="691">691</a>
<a href="#692" id="692">692</a>
<a href="#693" id="693">693</a>
<a href="#694" id="694">694</a>
<a href="#695" id="695">695</a>
<a href="#696" id="696">696</a>
<a href="#697" id="697">697</a>
<a href="#698" id="698">698</a>
<a href="#699" id="699">699</a>
<a href="#700" id="700">700</a>
<a href="#701" id="701">701</a>
<a href="#702" id="702">702</a>
<a href="#703" id="703">703</a>
<a href="#704" id="704">704</a>
<a href="#705" id="705">705</a>
<a href="#706" id="706">706</a>
<a href="#707" id="707">707</a>
<a href="#708" id="708">708</a>
<a href="#709" id="709">709</a>
<a href="#710" id="710">710</a>
<a href="#711" id="711">711</a>
<a href="#712" id="712">712</a>
<a href="#713" id="713">713</a>
<a href="#714" id="714">714</a>
<a href="#715" id="715">715</a>
<a href="#716" id="716">716</a>
<a href="#717" id="717">717</a>
<a href="#718" id="718">718</a>
<a href="#719" id="719">719</a>
<a href="#720" id="720">720</a>
<a href="#721" id="721">721</a>
<a href="#722" id="722">722</a>
<a href="#723" id="723">723</a>
<a href="#724" id="724">724</a>
<a href="#725" id="725">725</a>
<a href="#726" id="726">726</a>
<a href="#727" id="727">727</a>
<a href="#728" id="728">728</a>
<a href="#729" id="729">729</a>
<a href="#730" id="730">730</a>
<a href="#731" id="731">731</a>
<a href="#732" id="732">732</a>
<a href="#733" id="733">733</a>
<a href="#734" id="734">734</a>
<a href="#735" id="735">735</a>
<a href="#736" id="736">736</a>
<a href="#737" id="737">737</a>
<a href="#738" id="738">738</a>
<a href="#739" id="739">739</a>
<a href="#740" id="740">740</a>
<a href="#741" id="741">741</a>
<a href="#742" id="742">742</a>
<a href="#743" id="743">743</a>
<a href="#744" id="744">744</a>
<a href="#745" id="745">745</a>
<a href="#746" id="746">746</a>
<a href="#747" id="747">747</a>
<a href="#748" id="748">748</a>
<a href="#749" id="749">749</a>
<a href="#750" id="750">750</a>
<a href="#751" id="751">751</a>
<a href="#752" id="752">752</a>
<a href="#753" id="753">753</a>
<a href="#754" id="754">754</a>
<a href="#755" id="755">755</a>
<a href="#756" id="756">756</a>
<a href="#757" id="757">757</a>
<a href="#758" id="758">758</a>
<a href="#759" id="759">759</a>
<a href="#760" id="760">760</a>
<a href="#761" id="761">761</a>
<a href="#762" id="762">762</a>
<a href="#763" id="763">763</a>
<a href="#764" id="764">764</a>
<a href="#765" id="765">765</a>
<a href="#766" id="766">766</a>
<a href="#767" id="767">767</a>
<a href="#768" id="768">768</a>
<a href="#769" id="769">769</a>
<a href="#770" id="770">770</a>
<a href="#771" id="771">771</a>
<a href="#772" id="772">772</a>
<a href="#773" id="773">773</a>
<a href="#774" id="774">774</a>
<a href="#775" id="775">775</a>
<a href="#776" id="776">776</a>
<a href="#777" id="777">777</a>
<a href="#778" id="778">778</a>
<a href="#779" id="779">779</a>
<a href="#780" id="780">780</a>
<a href="#781" id="781">781</a>
<a href="#782" id="782">782</a>
<a href="#783" id="783">783</a>
<a href="#784" id="784">784</a>
<a href="#785" id="785">785</a>
<a href="#786" id="786">786</a>
<a href="#787" id="787">787</a>
<a href="#788" id="788">788</a>
<a href="#789" id="789">789</a>
<a href="#790" id="790">790</a>
<a href="#791" id="791">791</a>
<a href="#792" id="792">792</a>
<a href="#793" id="793">793</a>
<a href="#794" id="794">794</a>
<a href="#795" id="795">795</a>
<a href="#796" id="796">796</a>
<a href="#797" id="797">797</a>
<a href="#798" id="798">798</a>
<a href="#799" id="799">799</a>
<a href="#800" id="800">800</a>
<a href="#801" id="801">801</a>
<a href="#802" id="802">802</a>
<a href="#803" id="803">803</a>
<a href="#804" id="804">804</a>
<a href="#805" id="805">805</a>
<a href="#806" id="806">806</a>
<a href="#807" id="807">807</a>
<a href="#808" id="808">808</a>
<a href="#809" id="809">809</a>
<a href="#810" id="810">810</a>
<a href="#811" id="811">811</a>
<a href="#812" id="812">812</a>
<a href="#813" id="813">813</a>
<a href="#814" id="814">814</a>
<a href="#815" id="815">815</a>
<a href="#816" id="816">816</a>
<a href="#817" id="817">817</a>
<a href="#818" id="818">818</a>
<a href="#819" id="819">819</a>
<a href="#820" id="820">820</a>
<a href="#821" id="821">821</a>
<a href="#822" id="822">822</a>
<a href="#823" id="823">823</a>
<a href="#824" id="824">824</a>
<a href="#825" id="825">825</a>
<a href="#826" id="826">826</a>
<a href="#827" id="827">827</a>
<a href="#828" id="828">828</a>
<a href="#829" id="829">829</a>
<a href="#830" id="830">830</a>
<a href="#831" id="831">831</a>
<a href="#832" id="832">832</a>
<a href="#833" id="833">833</a>
<a href="#834" id="834">834</a>
<a href="#835" id="835">835</a>
<a href="#836" id="836">836</a>
<a href="#837" id="837">837</a>
<a href="#838" id="838">838</a>
<a href="#839" id="839">839</a>
<a href="#840" id="840">840</a>
<a href="#841" id="841">841</a>
<a href="#842" id="842">842</a>
<a href="#843" id="843">843</a>
<a href="#844" id="844">844</a>
<a href="#845" id="845">845</a>
<a href="#846" id="846">846</a>
<a href="#847" id="847">847</a>
<a href="#848" id="848">848</a>
<a href="#849" id="849">849</a>
<a href="#850" id="850">850</a>
<a href="#851" id="851">851</a>
<a href="#852" id="852">852</a>
<a href="#853" id="853">853</a>
<a href="#854" id="854">854</a>
<a href="#855" id="855">855</a>
<a href="#856" id="856">856</a>
<a href="#857" id="857">857</a>
<a href="#858" id="858">858</a>
<a href="#859" id="859">859</a>
<a href="#860" id="860">860</a>
<a href="#861" id="861">861</a>
<a href="#862" id="862">862</a>
<a href="#863" id="863">863</a>
<a href="#864" id="864">864</a>
<a href="#865" id="865">865</a>
<a href="#866" id="866">866</a>
<a href="#867" id="867">867</a>
<a href="#868" id="868">868</a>
<a href="#869" id="869">869</a>
<a href="#870" id="870">870</a>
<a href="#871" id="871">871</a>
<a href="#872" id="872">872</a>
<a href="#873" id="873">873</a>
<a href="#874" id="874">874</a>
<a href="#875" id="875">875</a>
<a href="#876" id="876">876</a>
<a href="#877" id="877">877</a>
<a href="#878" id="878">878</a>
<a href="#879" id="879">879</a>
<a href="#880" id="880">880</a>
<a href="#881" id="881">881</a>
<a href="#882" id="882">882</a>
<a href="#883" id="883">883</a>
<a href="#884" id="884">884</a>
<a href="#885" id="885">885</a>
<a href="#886" id="886">886</a>
<a href="#887" id="887">887</a>
<a href="#888" id="888">888</a>
<a href="#889" id="889">889</a>
<a href="#890" id="890">890</a>
<a href="#891" id="891">891</a>
<a href="#892" id="892">892</a>
<a href="#893" id="893">893</a>
<a href="#894" id="894">894</a>
<a href="#895" id="895">895</a>
<a href="#896" id="896">896</a>
<a href="#897" id="897">897</a>
<a href="#898" id="898">898</a>
<a href="#899" id="899">899</a>
<a href="#900" id="900">900</a>
<a href="#901" id="901">901</a>
<a href="#902" id="902">902</a>
<a href="#903" id="903">903</a>
<a href="#904" id="904">904</a>
<a href="#905" id="905">905</a>
<a href="#906" id="906">906</a>
<a href="#907" id="907">907</a>
<a href="#908" id="908">908</a>
<a href="#909" id="909">909</a>
<a href="#910" id="910">910</a>
<a href="#911" id="911">911</a>
<a href="#912" id="912">912</a>
<a href="#913" id="913">913</a>
<a href="#914" id="914">914</a>
<a href="#915" id="915">915</a>
<a href="#916" id="916">916</a>
<a href="#917" id="917">917</a>
<a href="#918" id="918">918</a>
<a href="#919" id="919">919</a>
<a href="#920" id="920">920</a>
<a href="#921" id="921">921</a>
<a href="#922" id="922">922</a>
<a href="#923" id="923">923</a>
<a href="#924" id="924">924</a>
<a href="#925" id="925">925</a>
<a href="#926" id="926">926</a>
<a href="#927" id="927">927</a>
<a href="#928" id="928">928</a>
<a href="#929" id="929">929</a>
<a href="#930" id="930">930</a>
<a href="#931" id="931">931</a>
<a href="#932" id="932">932</a>
<a href="#933" id="933">933</a>
<a href="#934" id="934">934</a>
<a href="#935" id="935">935</a>
<a href="#936" id="936">936</a>
<a href="#937" id="937">937</a>
<a href="#938" id="938">938</a>
<a href="#939" id="939">939</a>
<a href="#940" id="940">940</a>
<a href="#941" id="941">941</a>
<a href="#942" id="942">942</a>
<a href="#943" id="943">943</a>
<a href="#944" id="944">944</a>
<a href="#945" id="945">945</a>
<a href="#946" id="946">946</a>
<a href="#947" id="947">947</a>
<a href="#948" id="948">948</a>
<a href="#949" id="949">949</a>
<a href="#950" id="950">950</a>
<a href="#951" id="951">951</a>
<a href="#952" id="952">952</a>
<a href="#953" id="953">953</a>
<a href="#954" id="954">954</a>
<a href="#955" id="955">955</a>
<a href="#956" id="956">956</a>
<a href="#957" id="957">957</a>
<a href="#958" id="958">958</a>
<a href="#959" id="959">959</a>
<a href="#960" id="960">960</a>
<a href="#961" id="961">961</a>
<a href="#962" id="962">962</a>
<a href="#963" id="963">963</a>
<a href="#964" id="964">964</a>
<a href="#965" id="965">965</a>
<a href="#966" id="966">966</a>
<a href="#967" id="967">967</a>
<a href="#968" id="968">968</a>
<a href="#969" id="969">969</a>
<a href="#970" id="970">970</a>
<a href="#971" id="971">971</a>
<a href="#972" id="972">972</a>
<a href="#973" id="973">973</a>
<a href="#974" id="974">974</a>
<a href="#975" id="975">975</a>
<a href="#976" id="976">976</a>
<a href="#977" id="977">977</a>
<a href="#978" id="978">978</a>
<a href="#979" id="979">979</a>
<a href="#980" id="980">980</a>
<a href="#981" id="981">981</a>
<a href="#982" id="982">982</a>
<a href="#983" id="983">983</a>
<a href="#984" id="984">984</a>
<a href="#985" id="985">985</a>
<a href="#986" id="986">986</a>
<a href="#987" id="987">987</a>
<a href="#988" id="988">988</a>
<a href="#989" id="989">989</a>
<a href="#990" id="990">990</a>
<a href="#991" id="991">991</a>
<a href="#992" id="992">992</a>
<a href="#993" id="993">993</a>
<a href="#994" id="994">994</a>
<a href="#995" id="995">995</a>
<a href="#996" id="996">996</a>
<a href="#997" id="997">997</a>
<a href="#998" id="998">998</a>
<a href="#999" id="999">999</a>
<a href="#1000" id="1000">1000</a>
<a href="#1001" id="1001">1001</a>
<a href="#1002" id="1002">1002</a>
<a href="#1003" id="1003">1003</a>
<a href="#1004" id="1004">1004</a>
<a href="#1005" id="1005">1005</a>
<a href="#1006" id="1006">1006</a>
<a href="#1007" id="1007">1007</a>
<a href="#1008" id="1008">1008</a>
<a href="#1009" id="1009">1009</a>
<a href="#1010" id="1010">1010</a>
<a href="#1011" id="1011">1011</a>
<a href="#1012" id="1012">1012</a>
<a href="#1013" id="1013">1013</a>
<a href="#1014" id="1014">1014</a>
<a href="#1015" id="1015">1015</a>
<a href="#1016" id="1016">1016</a>
<a href="#1017" id="1017">1017</a>
<a href="#1018" id="1018">1018</a>
<a href="#1019" id="1019">1019</a>
<a href="#1020" id="1020">1020</a>
<a href="#1021" id="1021">1021</a>
<a href="#1022" id="1022">1022</a>
<a href="#1023" id="1023">1023</a>
<a href="#1024" id="1024">1024</a>
<a href="#1025" id="1025">1025</a>
<a href="#1026" id="1026">1026</a>
<a href="#1027" id="1027">1027</a>
<a href="#1028" id="1028">1028</a>
<a href="#1029" id="1029">1029</a>
<a href="#1030" id="1030">1030</a>
<a href="#1031" id="1031">1031</a>
<a href="#1032" id="1032">1032</a>
<a href="#1033" id="1033">1033</a>
<a href="#1034" id="1034">1034</a>
<a href="#1035" id="1035">1035</a>
<a href="#1036" id="1036">1036</a>
<a href="#1037" id="1037">1037</a>
<a href="#1038" id="1038">1038</a>
<a href="#1039" id="1039">1039</a>
<a href="#1040" id="1040">1040</a>
<a href="#1041" id="1041">1041</a>
<a href="#1042" id="1042">1042</a>
<a href="#1043" id="1043">1043</a>
<a href="#1044" id="1044">1044</a>
<a href="#1045" id="1045">1045</a>
<a href="#1046" id="1046">1046</a>
<a href="#1047" id="1047">1047</a>
<a href="#1048" id="1048">1048</a>
<a href="#1049" id="1049">1049</a>
<a href="#1050" id="1050">1050</a>
<a href="#1051" id="1051">1051</a>
<a href="#1052" id="1052">1052</a>
<a href="#1053" id="1053">1053</a>
<a href="#1054" id="1054">1054</a>
<a href="#1055" id="1055">1055</a>
<a href="#1056" id="1056">1056</a>
<a href="#1057" id="1057">1057</a>
<a href="#1058" id="1058">1058</a>
<a href="#1059" id="1059">1059</a>
<a href="#1060" id="1060">1060</a>
<a href="#1061" id="1061">1061</a>
<a href="#1062" id="1062">1062</a>
<a href="#1063" id="1063">1063</a>
<a href="#1064" id="1064">1064</a>
<a href="#1065" id="1065">1065</a>
<a href="#1066" id="1066">1066</a>
<a href="#1067" id="1067">1067</a>
<a href="#1068" id="1068">1068</a>
<a href="#1069" id="1069">1069</a>
<a href="#1070" id="1070">1070</a>
<a href="#1071" id="1071">1071</a>
<a href="#1072" id="1072">1072</a>
<a href="#1073" id="1073">1073</a>
<a href="#1074" id="1074">1074</a>
<a href="#1075" id="1075">1075</a>
<a href="#1076" id="1076">1076</a>
<a href="#1077" id="1077">1077</a>
<a href="#1078" id="1078">1078</a>
<a href="#1079" id="1079">1079</a>
<a href="#1080" id="1080">1080</a>
<a href="#1081" id="1081">1081</a>
<a href="#1082" id="1082">1082</a>
<a href="#1083" id="1083">1083</a>
<a href="#1084" id="1084">1084</a>
<a href="#1085" id="1085">1085</a>
<a href="#1086" id="1086">1086</a>
<a href="#1087" id="1087">1087</a>
<a href="#1088" id="1088">1088</a>
<a href="#1089" id="1089">1089</a>
<a href="#1090" id="1090">1090</a>
<a href="#1091" id="1091">1091</a>
<a href="#1092" id="1092">1092</a>
<a href="#1093" id="1093">1093</a>
<a href="#1094" id="1094">1094</a>
<a href="#1095" id="1095">1095</a>
<a href="#1096" id="1096">1096</a>
<a href="#1097" id="1097">1097</a>
<a href="#1098" id="1098">1098</a>
<a href="#1099" id="1099">1099</a>
<a href="#1100" id="1100">1100</a>
<a href="#1101" id="1101">1101</a>
<a href="#1102" id="1102">1102</a>
<a href="#1103" id="1103">1103</a>
<a href="#1104" id="1104">1104</a>
<a href="#1105" id="1105">1105</a>
<a href="#1106" id="1106">1106</a>
<a href="#1107" id="1107">1107</a>
<a href="#1108" id="1108">1108</a>
<a href="#1109" id="1109">1109</a>
<a href="#1110" id="1110">1110</a>
<a href="#1111" id="1111">1111</a>
<a href="#1112" id="1112">1112</a>
<a href="#1113" id="1113">1113</a>
<a href="#1114" id="1114">1114</a>
<a href="#1115" id="1115">1115</a>
<a href="#1116" id="1116">1116</a>
<a href="#1117" id="1117">1117</a>
<a href="#1118" id="1118">1118</a>
<a href="#1119" id="1119">1119</a>
<a href="#1120" id="1120">1120</a>
<a href="#1121" id="1121">1121</a>
<a href="#1122" id="1122">1122</a>
<a href="#1123" id="1123">1123</a>
<a href="#1124" id="1124">1124</a>
<a href="#1125" id="1125">1125</a>
<a href="#1126" id="1126">1126</a>
<a href="#1127" id="1127">1127</a>
<a href="#1128" id="1128">1128</a>
<a href="#1129" id="1129">1129</a>
<a href="#1130" id="1130">1130</a>
<a href="#1131" id="1131">1131</a>
<a href="#1132" id="1132">1132</a>
<a href="#1133" id="1133">1133</a>
<a href="#1134" id="1134">1134</a>
<a href="#1135" id="1135">1135</a>
<a href="#1136" id="1136">1136</a>
<a href="#1137" id="1137">1137</a>
<a href="#1138" id="1138">1138</a>
<a href="#1139" id="1139">1139</a>
<a href="#1140" id="1140">1140</a>
<a href="#1141" id="1141">1141</a>
<a href="#1142" id="1142">1142</a>
<a href="#1143" id="1143">1143</a>
<a href="#1144" id="1144">1144</a>
<a href="#1145" id="1145">1145</a>
<a href="#1146" id="1146">1146</a>
<a href="#1147" id="1147">1147</a>
<a href="#1148" id="1148">1148</a>
<a href="#1149" id="1149">1149</a>
<a href="#1150" id="1150">1150</a>
<a href="#1151" id="1151">1151</a>
<a href="#1152" id="1152">1152</a>
<a href="#1153" id="1153">1153</a>
<a href="#1154" id="1154">1154</a>
<a href="#1155" id="1155">1155</a>
<a href="#1156" id="1156">1156</a>
<a href="#1157" id="1157">1157</a>
<a href="#1158" id="1158">1158</a>
<a href="#1159" id="1159">1159</a>
<a href="#1160" id="1160">1160</a>
<a href="#1161" id="1161">1161</a>
<a href="#1162" id="1162">1162</a>
<a href="#1163" id="1163">1163</a>
<a href="#1164" id="1164">1164</a>
<a href="#1165" id="1165">1165</a>
<a href="#1166" id="1166">1166</a>
<a href="#1167" id="1167">1167</a>
<a href="#1168" id="1168">1168</a>
<a href="#1169" id="1169">1169</a>
<a href="#1170" id="1170">1170</a>
<a href="#1171" id="1171">1171</a>
<a href="#1172" id="1172">1172</a>
<a href="#1173" id="1173">1173</a>
<a href="#1174" id="1174">1174</a>
<a href="#1175" id="1175">1175</a>
<a href="#1176" id="1176">1176</a>
<a href="#1177" id="1177">1177</a>
<a href="#1178" id="1178">1178</a>
<a href="#1179" id="1179">1179</a>
<a href="#1180" id="1180">1180</a>
<a href="#1181" id="1181">1181</a>
<a href="#1182" id="1182">1182</a>
<a href="#1183" id="1183">1183</a>
<a href="#1184" id="1184">1184</a>
<a href="#1185" id="1185">1185</a>
<a href="#1186" id="1186">1186</a>
<a href="#1187" id="1187">1187</a>
<a href="#1188" id="1188">1188</a>
<a href="#1189" id="1189">1189</a>
<a href="#1190" id="1190">1190</a>
<a href="#1191" id="1191">1191</a>
<a href="#1192" id="1192">1192</a>
<a href="#1193" id="1193">1193</a>
<a href="#1194" id="1194">1194</a>
<a href="#1195" id="1195">1195</a>
<a href="#1196" id="1196">1196</a>
<a href="#1197" id="1197">1197</a>
<a href="#1198" id="1198">1198</a>
<a href="#1199" id="1199">1199</a>
<a href="#1200" id="1200">1200</a>
<a href="#1201" id="1201">1201</a>
<a href="#1202" id="1202">1202</a>
<a href="#1203" id="1203">1203</a>
<a href="#1204" id="1204">1204</a>
<a href="#1205" id="1205">1205</a>
<a href="#1206" id="1206">1206</a>
<a href="#1207" id="1207">1207</a>
<a href="#1208" id="1208">1208</a>
<a href="#1209" id="1209">1209</a>
<a href="#1210" id="1210">1210</a>
<a href="#1211" id="1211">1211</a>
<a href="#1212" id="1212">1212</a>
<a href="#1213" id="1213">1213</a>
<a href="#1214" id="1214">1214</a>
<a href="#1215" id="1215">1215</a>
<a href="#1216" id="1216">1216</a>
<a href="#1217" id="1217">1217</a>
<a href="#1218" id="1218">1218</a>
<a href="#1219" id="1219">1219</a>
<a href="#1220" id="1220">1220</a>
<a href="#1221" id="1221">1221</a>
<a href="#1222" id="1222">1222</a>
<a href="#1223" id="1223">1223</a>
<a href="#1224" id="1224">1224</a>
<a href="#1225" id="1225">1225</a>
<a href="#1226" id="1226">1226</a>
<a href="#1227" id="1227">1227</a>
<a href="#1228" id="1228">1228</a>
<a href="#1229" id="1229">1229</a>
<a href="#1230" id="1230">1230</a>
<a href="#1231" id="1231">1231</a>
<a href="#1232" id="1232">1232</a>
<a href="#1233" id="1233">1233</a>
<a href="#1234" id="1234">1234</a>
<a href="#1235" id="1235">1235</a>
<a href="#1236" id="1236">1236</a>
<a href="#1237" id="1237">1237</a>
<a href="#1238" id="1238">1238</a>
<a href="#1239" id="1239">1239</a>
<a href="#1240" id="1240">1240</a>
<a href="#1241" id="1241">1241</a>
<a href="#1242" id="1242">1242</a>
<a href="#1243" id="1243">1243</a>
<a href="#1244" id="1244">1244</a>
<a href="#1245" id="1245">1245</a>
<a href="#1246" id="1246">1246</a>
<a href="#1247" id="1247">1247</a>
<a href="#1248" id="1248">1248</a>
<a href="#1249" id="1249">1249</a>
<a href="#1250" id="1250">1250</a>
<a href="#1251" id="1251">1251</a>
<a href="#1252" id="1252">1252</a>
<a href="#1253" id="1253">1253</a>
<a href="#1254" id="1254">1254</a>
<a href="#1255" id="1255">1255</a>
<a href="#1256" id="1256">1256</a>
<a href="#1257" id="1257">1257</a>
<a href="#1258" id="1258">1258</a>
<a href="#1259" id="1259">1259</a>
<a href="#1260" id="1260">1260</a>
<a href="#1261" id="1261">1261</a>
<a href="#1262" id="1262">1262</a>
<a href="#1263" id="1263">1263</a>
<a href="#1264" id="1264">1264</a>
<a href="#1265" id="1265">1265</a>
<a href="#1266" id="1266">1266</a>
<a href="#1267" id="1267">1267</a>
<a href="#1268" id="1268">1268</a>
<a href="#1269" id="1269">1269</a>
<a href="#1270" id="1270">1270</a>
<a href="#1271" id="1271">1271</a>
<a href="#1272" id="1272">1272</a>
<a href="#1273" id="1273">1273</a>
<a href="#1274" id="1274">1274</a>
<a href="#1275" id="1275">1275</a>
<a href="#1276" id="1276">1276</a>
<a href="#1277" id="1277">1277</a>
<a href="#1278" id="1278">1278</a>
<a href="#1279" id="1279">1279</a>
<a href="#1280" id="1280">1280</a>
<a href="#1281" id="1281">1281</a>
<a href="#1282" id="1282">1282</a>
<a href="#1283" id="1283">1283</a>
<a href="#1284" id="1284">1284</a>
<a href="#1285" id="1285">1285</a>
<a href="#1286" id="1286">1286</a>
<a href="#1287" id="1287">1287</a>
<a href="#1288" id="1288">1288</a>
<a href="#1289" id="1289">1289</a>
<a href="#1290" id="1290">1290</a>
<a href="#1291" id="1291">1291</a>
<a href="#1292" id="1292">1292</a>
<a href="#1293" id="1293">1293</a>
<a href="#1294" id="1294">1294</a>
<a href="#1295" id="1295">1295</a>
<a href="#1296" id="1296">1296</a>
<a href="#1297" id="1297">1297</a>
<a href="#1298" id="1298">1298</a>
<a href="#1299" id="1299">1299</a>
<a href="#1300" id="1300">1300</a>
<a href="#1301" id="1301">1301</a>
<a href="#1302" id="1302">1302</a>
<a href="#1303" id="1303">1303</a>
<a href="#1304" id="1304">1304</a>
<a href="#1305" id="1305">1305</a>
<a href="#1306" id="1306">1306</a>
<a href="#1307" id="1307">1307</a>
<a href="#1308" id="1308">1308</a>
<a href="#1309" id="1309">1309</a>
<a href="#1310" id="1310">1310</a>
<a href="#1311" id="1311">1311</a>
<a href="#1312" id="1312">1312</a>
<a href="#1313" id="1313">1313</a>
<a href="#1314" id="1314">1314</a>
<a href="#1315" id="1315">1315</a>
<a href="#1316" id="1316">1316</a>
<a href="#1317" id="1317">1317</a>
<a href="#1318" id="1318">1318</a>
<a href="#1319" id="1319">1319</a>
<a href="#1320" id="1320">1320</a>
<a href="#1321" id="1321">1321</a>
<a href="#1322" id="1322">1322</a>
<a href="#1323" id="1323">1323</a>
<a href="#1324" id="1324">1324</a>
<a href="#1325" id="1325">1325</a>
<a href="#1326" id="1326">1326</a>
<a href="#1327" id="1327">1327</a>
<a href="#1328" id="1328">1328</a>
<a href="#1329" id="1329">1329</a>
<a href="#1330" id="1330">1330</a>
<a href="#1331" id="1331">1331</a>
<a href="#1332" id="1332">1332</a>
<a href="#1333" id="1333">1333</a>
<a href="#1334" id="1334">1334</a>
<a href="#1335" id="1335">1335</a>
<a href="#1336" id="1336">1336</a>
<a href="#1337" id="1337">1337</a>
<a href="#1338" id="1338">1338</a>
<a href="#1339" id="1339">1339</a>
<a href="#1340" id="1340">1340</a>
<a href="#1341" id="1341">1341</a>
<a href="#1342" id="1342">1342</a>
<a href="#1343" id="1343">1343</a>
<a href="#1344" id="1344">1344</a>
<a href="#1345" id="1345">1345</a>
<a href="#1346" id="1346">1346</a>
<a href="#1347" id="1347">1347</a>
<a href="#1348" id="1348">1348</a>
<a href="#1349" id="1349">1349</a>
<a href="#1350" id="1350">1350</a>
<a href="#1351" id="1351">1351</a>
<a href="#1352" id="1352">1352</a>
<a href="#1353" id="1353">1353</a>
<a href="#1354" id="1354">1354</a>
<a href="#1355" id="1355">1355</a>
<a href="#1356" id="1356">1356</a>
<a href="#1357" id="1357">1357</a>
<a href="#1358" id="1358">1358</a>
<a href="#1359" id="1359">1359</a>
<a href="#1360" id="1360">1360</a>
<a href="#1361" id="1361">1361</a>
<a href="#1362" id="1362">1362</a>
<a href="#1363" id="1363">1363</a>
<a href="#1364" id="1364">1364</a>
<a href="#1365" id="1365">1365</a>
<a href="#1366" id="1366">1366</a>
<a href="#1367" id="1367">1367</a>
<a href="#1368" id="1368">1368</a>
<a href="#1369" id="1369">1369</a>
<a href="#1370" id="1370">1370</a>
<a href="#1371" id="1371">1371</a>
<a href="#1372" id="1372">1372</a>
<a href="#1373" id="1373">1373</a>
<a href="#1374" id="1374">1374</a>
<a href="#1375" id="1375">1375</a>
<a href="#1376" id="1376">1376</a>
<a href="#1377" id="1377">1377</a>
<a href="#1378" id="1378">1378</a>
<a href="#1379" id="1379">1379</a>
<a href="#1380" id="1380">1380</a>
<a href="#1381" id="1381">1381</a>
<a href="#1382" id="1382">1382</a>
<a href="#1383" id="1383">1383</a>
<a href="#1384" id="1384">1384</a>
<a href="#1385" id="1385">1385</a>
<a href="#1386" id="1386">1386</a>
<a href="#1387" id="1387">1387</a>
<a href="#1388" id="1388">1388</a>
<a href="#1389" id="1389">1389</a>
<a href="#1390" id="1390">1390</a>
<a href="#1391" id="1391">1391</a>
<a href="#1392" id="1392">1392</a>
<a href="#1393" id="1393">1393</a>
<a href="#1394" id="1394">1394</a>
<a href="#1395" id="1395">1395</a>
<a href="#1396" id="1396">1396</a>
<a href="#1397" id="1397">1397</a>
<a href="#1398" id="1398">1398</a>
<a href="#1399" id="1399">1399</a>
<a href="#1400" id="1400">1400</a>
<a href="#1401" id="1401">1401</a>
<a href="#1402" id="1402">1402</a>
<a href="#1403" id="1403">1403</a>
<a href="#1404" id="1404">1404</a>
<a href="#1405" id="1405">1405</a>
<a href="#1406" id="1406">1406</a>
<a href="#1407" id="1407">1407</a>
<a href="#1408" id="1408">1408</a>
<a href="#1409" id="1409">1409</a>
<a href="#1410" id="1410">1410</a>
<a href="#1411" id="1411">1411</a>
<a href="#1412" id="1412">1412</a>
<a href="#1413" id="1413">1413</a>
<a href="#1414" id="1414">1414</a>
<a href="#1415" id="1415">1415</a>
<a href="#1416" id="1416">1416</a>
<a href="#1417" id="1417">1417</a>
<a href="#1418" id="1418">1418</a>
<a href="#1419" id="1419">1419</a>
<a href="#1420" id="1420">1420</a>
<a href="#1421" id="1421">1421</a>
<a href="#1422" id="1422">1422</a>
<a href="#1423" id="1423">1423</a>
<a href="#1424" id="1424">1424</a>
<a href="#1425" id="1425">1425</a>
<a href="#1426" id="1426">1426</a>
<a href="#1427" id="1427">1427</a>
<a href="#1428" id="1428">1428</a>
<a href="#1429" id="1429">1429</a>
<a href="#1430" id="1430">1430</a>
<a href="#1431" id="1431">1431</a>
<a href="#1432" id="1432">1432</a>
<a href="#1433" id="1433">1433</a>
<a href="#1434" id="1434">1434</a>
<a href="#1435" id="1435">1435</a>
<a href="#1436" id="1436">1436</a>
<a href="#1437" id="1437">1437</a>
<a href="#1438" id="1438">1438</a>
<a href="#1439" id="1439">1439</a>
<a href="#1440" id="1440">1440</a>
<a href="#1441" id="1441">1441</a>
<a href="#1442" id="1442">1442</a>
<a href="#1443" id="1443">1443</a>
<a href="#1444" id="1444">1444</a>
<a href="#1445" id="1445">1445</a>
<a href="#1446" id="1446">1446</a>
<a href="#1447" id="1447">1447</a>
<a href="#1448" id="1448">1448</a>
<a href="#1449" id="1449">1449</a>
<a href="#1450" id="1450">1450</a>
<a href="#1451" id="1451">1451</a>
<a href="#1452" id="1452">1452</a>
<a href="#1453" id="1453">1453</a>
<a href="#1454" id="1454">1454</a>
<a href="#1455" id="1455">1455</a>
<a href="#1456" id="1456">1456</a>
<a href="#1457" id="1457">1457</a>
<a href="#1458" id="1458">1458</a>
<a href="#1459" id="1459">1459</a>
<a href="#1460" id="1460">1460</a>
<a href="#1461" id="1461">1461</a>
<a href="#1462" id="1462">1462</a>
<a href="#1463" id="1463">1463</a>
<a href="#1464" id="1464">1464</a>
<a href="#1465" id="1465">1465</a>
<a href="#1466" id="1466">1466</a>
<a href="#1467" id="1467">1467</a>
<a href="#1468" id="1468">1468</a>
<a href="#1469" id="1469">1469</a>
<a href="#1470" id="1470">1470</a>
<a href="#1471" id="1471">1471</a>
<a href="#1472" id="1472">1472</a>
<a href="#1473" id="1473">1473</a>
<a href="#1474" id="1474">1474</a>
<a href="#1475" id="1475">1475</a>
<a href="#1476" id="1476">1476</a>
<a href="#1477" id="1477">1477</a>
<a href="#1478" id="1478">1478</a>
<a href="#1479" id="1479">1479</a>
<a href="#1480" id="1480">1480</a>
<a href="#1481" id="1481">1481</a>
<a href="#1482" id="1482">1482</a>
<a href="#1483" id="1483">1483</a>
<a href="#1484" id="1484">1484</a>
<a href="#1485" id="1485">1485</a>
<a href="#1486" id="1486">1486</a>
<a href="#1487" id="1487">1487</a>
<a href="#1488" id="1488">1488</a>
<a href="#1489" id="1489">1489</a>
<a href="#1490" id="1490">1490</a>
<a href="#1491" id="1491">1491</a>
<a href="#1492" id="1492">1492</a>
<a href="#1493" id="1493">1493</a>
<a href="#1494" id="1494">1494</a>
<a href="#1495" id="1495">1495</a>
<a href="#1496" id="1496">1496</a>
<a href="#1497" id="1497">1497</a>
<a href="#1498" id="1498">1498</a>
<a href="#1499" id="1499">1499</a>
<a href="#1500" id="1500">1500</a>
<a href="#1501" id="1501">1501</a>
<a href="#1502" id="1502">1502</a>
<a href="#1503" id="1503">1503</a>
<a href="#1504" id="1504">1504</a>
<a href="#1505" id="1505">1505</a>
<a href="#1506" id="1506">1506</a>
<a href="#1507" id="1507">1507</a>
<a href="#1508" id="1508">1508</a>
<a href="#1509" id="1509">1509</a>
<a href="#1510" id="1510">1510</a>
<a href="#1511" id="1511">1511</a>
<a href="#1512" id="1512">1512</a>
<a href="#1513" id="1513">1513</a>
<a href="#1514" id="1514">1514</a>
<a href="#1515" id="1515">1515</a>
<a href="#1516" id="1516">1516</a>
<a href="#1517" id="1517">1517</a>
<a href="#1518" id="1518">1518</a>
<a href="#1519" id="1519">1519</a>
<a href="#1520" id="1520">1520</a>
<a href="#1521" id="1521">1521</a>
<a href="#1522" id="1522">1522</a>
<a href="#1523" id="1523">1523</a>
<a href="#1524" id="1524">1524</a>
<a href="#1525" id="1525">1525</a>
<a href="#1526" id="1526">1526</a>
<a href="#1527" id="1527">1527</a>
<a href="#1528" id="1528">1528</a>
<a href="#1529" id="1529">1529</a>
<a href="#1530" id="1530">1530</a>
<a href="#1531" id="1531">1531</a>
<a href="#1532" id="1532">1532</a>
<a href="#1533" id="1533">1533</a>
<a href="#1534" id="1534">1534</a>
<a href="#1535" id="1535">1535</a>
<a href="#1536" id="1536">1536</a>
<a href="#1537" id="1537">1537</a>
<a href="#1538" id="1538">1538</a>
<a href="#1539" id="1539">1539</a>
<a href="#1540" id="1540">1540</a>
<a href="#1541" id="1541">1541</a>
<a href="#1542" id="1542">1542</a>
<a href="#1543" id="1543">1543</a>
<a href="#1544" id="1544">1544</a>
<a href="#1545" id="1545">1545</a>
<a href="#1546" id="1546">1546</a>
<a href="#1547" id="1547">1547</a>
<a href="#1548" id="1548">1548</a>
<a href="#1549" id="1549">1549</a>
<a href="#1550" id="1550">1550</a>
<a href="#1551" id="1551">1551</a>
<a href="#1552" id="1552">1552</a>
<a href="#1553" id="1553">1553</a>
<a href="#1554" id="1554">1554</a>
<a href="#1555" id="1555">1555</a>
<a href="#1556" id="1556">1556</a>
<a href="#1557" id="1557">1557</a>
<a href="#1558" id="1558">1558</a>
<a href="#1559" id="1559">1559</a>
<a href="#1560" id="1560">1560</a>
<a href="#1561" id="1561">1561</a>
<a href="#1562" id="1562">1562</a>
<a href="#1563" id="1563">1563</a>
<a href="#1564" id="1564">1564</a>
<a href="#1565" id="1565">1565</a>
<a href="#1566" id="1566">1566</a>
<a href="#1567" id="1567">1567</a>
<a href="#1568" id="1568">1568</a>
<a href="#1569" id="1569">1569</a>
<a href="#1570" id="1570">1570</a>
<a href="#1571" id="1571">1571</a>
<a href="#1572" id="1572">1572</a>
<a href="#1573" id="1573">1573</a>
<a href="#1574" id="1574">1574</a>
<a href="#1575" id="1575">1575</a>
<a href="#1576" id="1576">1576</a>
<a href="#1577" id="1577">1577</a>
<a href="#1578" id="1578">1578</a>
<a href="#1579" id="1579">1579</a>
<a href="#1580" id="1580">1580</a>
<a href="#1581" id="1581">1581</a>
<a href="#1582" id="1582">1582</a>
<a href="#1583" id="1583">1583</a>
<a href="#1584" id="1584">1584</a>
<a href="#1585" id="1585">1585</a>
<a href="#1586" id="1586">1586</a>
<a href="#1587" id="1587">1587</a>
<a href="#1588" id="1588">1588</a>
<a href="#1589" id="1589">1589</a>
<a href="#1590" id="1590">1590</a>
<a href="#1591" id="1591">1591</a>
<a href="#1592" id="1592">1592</a>
<a href="#1593" id="1593">1593</a>
<a href="#1594" id="1594">1594</a>
<a href="#1595" id="1595">1595</a>
<a href="#1596" id="1596">1596</a>
</pre></div><pre class="rust"><code><span class="comment">/*
This file is auto-generated from the public API of the zstd library.
It is released under the same BSD license.

BSD License

For Zstandard software

Copyright (c) Meta Platforms, Inc. and affiliates. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name Facebook, nor Meta, nor the names of its contributors may
   be used to endorse or promote products derived from this software without
   specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* automatically generated by rust-bindgen 0.66.1 */

</span><span class="kw">pub const </span>ZSTD_VERSION_MAJOR: u32 = <span class="number">1</span>;
<span class="kw">pub const </span>ZSTD_VERSION_MINOR: u32 = <span class="number">5</span>;
<span class="kw">pub const </span>ZSTD_VERSION_RELEASE: u32 = <span class="number">5</span>;
<span class="kw">pub const </span>ZSTD_VERSION_NUMBER: u32 = <span class="number">10505</span>;
<span class="kw">pub const </span>ZSTD_CLEVEL_DEFAULT: u32 = <span class="number">3</span>;
<span class="kw">pub const </span>ZSTD_MAGICNUMBER: u32 = <span class="number">4247762216</span>;
<span class="kw">pub const </span>ZSTD_MAGIC_DICTIONARY: u32 = <span class="number">3962610743</span>;
<span class="kw">pub const </span>ZSTD_MAGIC_SKIPPABLE_START: u32 = <span class="number">407710288</span>;
<span class="kw">pub const </span>ZSTD_MAGIC_SKIPPABLE_MASK: u32 = <span class="number">4294967280</span>;
<span class="kw">pub const </span>ZSTD_BLOCKSIZELOG_MAX: u32 = <span class="number">17</span>;
<span class="kw">pub const </span>ZSTD_BLOCKSIZE_MAX: u32 = <span class="number">131072</span>;
<span class="kw">pub const </span>ZSTD_CONTENTSIZE_UNKNOWN: i32 = -<span class="number">1</span>;
<span class="kw">pub const </span>ZSTD_CONTENTSIZE_ERROR: i32 = -<span class="number">2</span>;
<span class="kw">pub const </span>ZSTD_FRAMEHEADERSIZE_MAX: u32 = <span class="number">18</span>;
<span class="kw">pub const </span>ZSTD_SKIPPABLEHEADERSIZE: u32 = <span class="number">8</span>;
<span class="kw">pub const </span>ZSTD_WINDOWLOG_MAX_32: u32 = <span class="number">30</span>;
<span class="kw">pub const </span>ZSTD_WINDOWLOG_MAX_64: u32 = <span class="number">31</span>;
<span class="kw">pub const </span>ZSTD_WINDOWLOG_MIN: u32 = <span class="number">10</span>;
<span class="kw">pub const </span>ZSTD_HASHLOG_MIN: u32 = <span class="number">6</span>;
<span class="kw">pub const </span>ZSTD_CHAINLOG_MAX_32: u32 = <span class="number">29</span>;
<span class="kw">pub const </span>ZSTD_CHAINLOG_MAX_64: u32 = <span class="number">30</span>;
<span class="kw">pub const </span>ZSTD_CHAINLOG_MIN: u32 = <span class="number">6</span>;
<span class="kw">pub const </span>ZSTD_SEARCHLOG_MIN: u32 = <span class="number">1</span>;
<span class="kw">pub const </span>ZSTD_MINMATCH_MAX: u32 = <span class="number">7</span>;
<span class="kw">pub const </span>ZSTD_MINMATCH_MIN: u32 = <span class="number">3</span>;
<span class="kw">pub const </span>ZSTD_TARGETLENGTH_MAX: u32 = <span class="number">131072</span>;
<span class="kw">pub const </span>ZSTD_TARGETLENGTH_MIN: u32 = <span class="number">0</span>;
<span class="kw">pub const </span>ZSTD_BLOCKSIZE_MAX_MIN: u32 = <span class="number">1024</span>;
<span class="kw">pub const </span>ZSTD_OVERLAPLOG_MIN: u32 = <span class="number">0</span>;
<span class="kw">pub const </span>ZSTD_OVERLAPLOG_MAX: u32 = <span class="number">9</span>;
<span class="kw">pub const </span>ZSTD_WINDOWLOG_LIMIT_DEFAULT: u32 = <span class="number">27</span>;
<span class="kw">pub const </span>ZSTD_LDM_HASHLOG_MIN: u32 = <span class="number">6</span>;
<span class="kw">pub const </span>ZSTD_LDM_MINMATCH_MIN: u32 = <span class="number">4</span>;
<span class="kw">pub const </span>ZSTD_LDM_MINMATCH_MAX: u32 = <span class="number">4096</span>;
<span class="kw">pub const </span>ZSTD_LDM_BUCKETSIZELOG_MIN: u32 = <span class="number">1</span>;
<span class="kw">pub const </span>ZSTD_LDM_BUCKETSIZELOG_MAX: u32 = <span class="number">8</span>;
<span class="kw">pub const </span>ZSTD_LDM_HASHRATELOG_MIN: u32 = <span class="number">0</span>;
<span class="kw">pub const </span>ZSTD_TARGETCBLOCKSIZE_MIN: u32 = <span class="number">64</span>;
<span class="kw">pub const </span>ZSTD_TARGETCBLOCKSIZE_MAX: u32 = <span class="number">131072</span>;
<span class="kw">pub const </span>ZSTD_SRCSIZEHINT_MIN: u32 = <span class="number">0</span>;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_versionNumber() :\n  Return runtime library version, the value is (MAJOR*100*100 + MINOR*100 + RELEASE)."</span>]
    </span><span class="kw">pub fn </span>ZSTD_versionNumber() -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_versionString() :\n  Return runtime library version, like \"1.4.5\". Requires v1.3.0+."</span>]
    </span><span class="kw">pub fn </span>ZSTD_versionString() -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">"  Simple API\n/\n/*! ZSTD_compress() :\n  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.\n  NOTE: Providing `dstCapacity &gt;= ZSTD_compressBound(srcSize)` guarantees that zstd will have\n        enough space to successfully compress the data.\n  @return : compressed size written into `dst` (&lt;= `dstCapacity),\n            or an error code if it fails (which can be tested using ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compress(
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompress() :\n  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.\n  `dstCapacity` is an upper bound of originalSize to regenerate.\n  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.\n  @return : the number of bytes decompressed into `dst` (&lt;= `dstCapacity`),\n            or an errorCode if it fails (which can be tested using ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompress(
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        compressedSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_getFrameContentSize(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; ::core::ffi::c_ulonglong;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getDecompressedSize() :\n  NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().\n  Both functions work the same way, but ZSTD_getDecompressedSize() blends\n  \"empty\", \"unknown\" and \"error\" results to the same return value (0),\n  while ZSTD_getFrameContentSize() gives them separate return values.\n @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise."</span>]
    </span><span class="kw">pub fn </span>ZSTD_getDecompressedSize(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; ::core::ffi::c_ulonglong;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_findFrameCompressedSize() : Requires v1.4.0+\n `src` should point to the start of a ZSTD frame or skippable frame.\n `srcSize` must be &gt;= first frame size\n @return : the compressed size of the first frame starting at `src`,\n           suitable to pass as `srcSize` to `ZSTD_decompress` or similar,\n        or an error code if input is invalid"</span>]
    </span><span class="kw">pub fn </span>ZSTD_findFrameCompressedSize(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressBound(srcSize: usize) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_isError(code: usize) -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_getErrorName(code: usize) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_minCLevel() -&gt; ::core::ffi::c_int;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_maxCLevel() -&gt; ::core::ffi::c_int;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_defaultCLevel() -&gt; ::core::ffi::c_int;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_CCtx_s {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[doc = <span class="string">"  Explicit context"</span>]
</span><span class="kw">pub type </span>ZSTD_CCtx = ZSTD_CCtx_s;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createCCtx() -&gt; <span class="kw-2">*mut </span>ZSTD_CCtx;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_freeCCtx(cctx: <span class="kw-2">*mut </span>ZSTD_CCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compressCCtx() :\n  Same as ZSTD_compress(), using an explicit ZSTD_CCtx.\n  Important : in order to behave similarly to `ZSTD_compress()`,\n  this function compresses at requested compression level,\n  __ignoring any other parameter__ .\n  If any advanced parameter was set using the advanced API,\n  they will all be reset. Only `compressionLevel` remains."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compressCCtx(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_DCtx_s {
    _unused: [u8; <span class="number">0</span>],
}
<span class="kw">pub type </span>ZSTD_DCtx = ZSTD_DCtx_s;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createDCtx() -&gt; <span class="kw-2">*mut </span>ZSTD_DCtx;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_freeDCtx(dctx: <span class="kw-2">*mut </span>ZSTD_DCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompressDCtx() :\n  Same as ZSTD_decompress(),\n  requires an allocated ZSTD_DCtx.\n  Compatible with sticky parameters."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompressDCtx(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="attr">#[repr(u32)]
#[doc = <span class="string">"  Advanced compression API (Requires v1.4.0+)"</span>]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_strategy {
    ZSTD_fast = <span class="number">1</span>,
    ZSTD_dfast = <span class="number">2</span>,
    ZSTD_greedy = <span class="number">3</span>,
    ZSTD_lazy = <span class="number">4</span>,
    ZSTD_lazy2 = <span class="number">5</span>,
    ZSTD_btlazy2 = <span class="number">6</span>,
    ZSTD_btopt = <span class="number">7</span>,
    ZSTD_btultra = <span class="number">8</span>,
    ZSTD_btultra2 = <span class="number">9</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_cParameter {
    ZSTD_c_compressionLevel = <span class="number">100</span>,
    ZSTD_c_windowLog = <span class="number">101</span>,
    ZSTD_c_hashLog = <span class="number">102</span>,
    ZSTD_c_chainLog = <span class="number">103</span>,
    ZSTD_c_searchLog = <span class="number">104</span>,
    ZSTD_c_minMatch = <span class="number">105</span>,
    ZSTD_c_targetLength = <span class="number">106</span>,
    ZSTD_c_strategy = <span class="number">107</span>,
    ZSTD_c_enableLongDistanceMatching = <span class="number">160</span>,
    ZSTD_c_ldmHashLog = <span class="number">161</span>,
    ZSTD_c_ldmMinMatch = <span class="number">162</span>,
    ZSTD_c_ldmBucketSizeLog = <span class="number">163</span>,
    ZSTD_c_ldmHashRateLog = <span class="number">164</span>,
    ZSTD_c_contentSizeFlag = <span class="number">200</span>,
    ZSTD_c_checksumFlag = <span class="number">201</span>,
    ZSTD_c_dictIDFlag = <span class="number">202</span>,
    ZSTD_c_nbWorkers = <span class="number">400</span>,
    ZSTD_c_jobSize = <span class="number">401</span>,
    ZSTD_c_overlapLog = <span class="number">402</span>,
    ZSTD_c_experimentalParam1 = <span class="number">500</span>,
    ZSTD_c_experimentalParam2 = <span class="number">10</span>,
    ZSTD_c_experimentalParam3 = <span class="number">1000</span>,
    ZSTD_c_experimentalParam4 = <span class="number">1001</span>,
    ZSTD_c_experimentalParam5 = <span class="number">1002</span>,
    ZSTD_c_experimentalParam6 = <span class="number">1003</span>,
    ZSTD_c_experimentalParam7 = <span class="number">1004</span>,
    ZSTD_c_experimentalParam8 = <span class="number">1005</span>,
    ZSTD_c_experimentalParam9 = <span class="number">1006</span>,
    ZSTD_c_experimentalParam10 = <span class="number">1007</span>,
    ZSTD_c_experimentalParam11 = <span class="number">1008</span>,
    ZSTD_c_experimentalParam12 = <span class="number">1009</span>,
    ZSTD_c_experimentalParam13 = <span class="number">1010</span>,
    ZSTD_c_experimentalParam14 = <span class="number">1011</span>,
    ZSTD_c_experimentalParam15 = <span class="number">1012</span>,
    ZSTD_c_experimentalParam16 = <span class="number">1013</span>,
    ZSTD_c_experimentalParam17 = <span class="number">1014</span>,
    ZSTD_c_experimentalParam18 = <span class="number">1015</span>,
    ZSTD_c_experimentalParam19 = <span class="number">1016</span>,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_bounds {
    <span class="kw">pub </span>error: usize,
    <span class="kw">pub </span>lowerBound: ::core::ffi::c_int,
    <span class="kw">pub </span>upperBound: ::core::ffi::c_int,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_cParam_getBounds() :\n  All parameters must belong to an interval with lower and upper bounds,\n  otherwise they will either trigger an error or be automatically clamped.\n @return : a structure, ZSTD_bounds, which contains\n         - an error status field, which must be tested using ZSTD_isError()\n         - lower and upper bounds, both inclusive"</span>]
    </span><span class="kw">pub fn </span>ZSTD_cParam_getBounds(cParam: ZSTD_cParameter) -&gt; ZSTD_bounds;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_setParameter() :\n  Set one compression parameter, selected by enum ZSTD_cParameter.\n  All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().\n  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).\n  Setting a parameter is generally only possible during frame initialization (before starting compression).\n  Exception : when using multi-threading mode (nbWorkers &gt;= 1),\n              the following parameters can be updated _during_ compression (within same frame):\n              =&gt; compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.\n              new parameters will be active for next job only (after a flush()).\n @return : an error code (which can be tested using ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_setParameter(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        param: ZSTD_cParameter,
        value: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_setPledgedSrcSize() :\n  Total input data size to be compressed as a single frame.\n  Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag.\n  This value will also be controlled at end of frame, and trigger an error if not respected.\n @result : 0, or an error code (which can be tested with ZSTD_isError()).\n  Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame.\n           In order to mean \"unknown content size\", pass constant ZSTD_CONTENTSIZE_UNKNOWN.\n           ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame.\n  Note 2 : pledgedSrcSize is only valid once, for the next frame.\n           It's discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN.\n  Note 3 : Whenever all input data is provided and consumed in a single round,\n           for example with ZSTD_compress2(),\n           or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),\n           this value is automatically overridden by srcSize instead."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_setPledgedSrcSize(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_ResetDirective {
    ZSTD_reset_session_only = <span class="number">1</span>,
    ZSTD_reset_parameters = <span class="number">2</span>,
    ZSTD_reset_session_and_parameters = <span class="number">3</span>,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_reset() :\n  There are 2 different things that can be reset, independently or jointly :\n  - The session : will stop compressing current frame, and make CCtx ready to start a new one.\n                  Useful after an error, or to interrupt any ongoing compression.\n                  Any internal data not yet flushed is cancelled.\n                  Compression parameters and dictionary remain unchanged.\n                  They will be used to compress next frame.\n                  Resetting session never fails.\n  - The parameters : changes all parameters back to \"default\".\n                  This also removes any reference to any dictionary or external sequence producer.\n                  Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)\n                  otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())\n  - Both : similar to resetting the session, followed by resetting parameters."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_reset(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        reset: ZSTD_ResetDirective,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compress2() :\n  Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API.\n  ZSTD_compress2() always starts a new frame.\n  Should cctx hold data from a previously unfinished frame, everything about it is forgotten.\n  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()\n  - The function is always blocking, returns when compression is completed.\n  NOTE: Providing `dstCapacity &gt;= ZSTD_compressBound(srcSize)` guarantees that zstd will have\n        enough space to successfully compress the data, though it is possible it fails for other reasons.\n @return : compressed size written into `dst` (&lt;= `dstCapacity),\n           or an error code if it fails (which can be tested using ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compress2(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="attr">#[repr(u32)]
#[doc = <span class="string">"  Advanced decompression API (Requires v1.4.0+)"</span>]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_dParameter {
    ZSTD_d_windowLogMax = <span class="number">100</span>,
    ZSTD_d_experimentalParam1 = <span class="number">1000</span>,
    ZSTD_d_experimentalParam2 = <span class="number">1001</span>,
    ZSTD_d_experimentalParam3 = <span class="number">1002</span>,
    ZSTD_d_experimentalParam4 = <span class="number">1003</span>,
    ZSTD_d_experimentalParam5 = <span class="number">1004</span>,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_dParam_getBounds() :\n  All parameters must belong to an interval with lower and upper bounds,\n  otherwise they will either trigger an error or be automatically clamped.\n @return : a structure, ZSTD_bounds, which contains\n         - an error status field, which must be tested using ZSTD_isError()\n         - both lower and upper bounds, inclusive"</span>]
    </span><span class="kw">pub fn </span>ZSTD_dParam_getBounds(dParam: ZSTD_dParameter) -&gt; ZSTD_bounds;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_setParameter() :\n  Set one compression parameter, selected by enum ZSTD_dParameter.\n  All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds().\n  Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).\n  Setting a parameter is only possible during frame initialization (before starting decompression).\n @return : 0, or an error code (which can be tested using ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_setParameter(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        param: ZSTD_dParameter,
        value: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_reset() :\n  Return a DCtx to clean state.\n  Session and parameters can be reset jointly or separately.\n  Parameters can only be reset when no active frame is being decompressed.\n @return : 0, or an error code, which can be tested with ZSTD_isError()"</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_reset(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        reset: ZSTD_ResetDirective,
    ) -&gt; usize;
}
<span class="attr">#[doc = <span class="string">"  Streaming"</span>]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_inBuffer_s {
    <span class="attr">#[doc = <span class="string">"&lt; start of input buffer"</span>]
    </span><span class="kw">pub </span>src: <span class="kw-2">*const </span>::core::ffi::c_void,
    <span class="attr">#[doc = <span class="string">"&lt; size of input buffer"</span>]
    </span><span class="kw">pub </span>size: usize,
    <span class="attr">#[doc = <span class="string">"&lt; position where reading stopped. Will be updated. Necessarily 0 &lt;= pos &lt;= size"</span>]
    </span><span class="kw">pub </span>pos: usize,
}
<span class="attr">#[doc = <span class="string">"  Streaming"</span>]
</span><span class="kw">pub type </span>ZSTD_inBuffer = ZSTD_inBuffer_s;
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_outBuffer_s {
    <span class="attr">#[doc = <span class="string">"&lt; start of output buffer"</span>]
    </span><span class="kw">pub </span>dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
    <span class="attr">#[doc = <span class="string">"&lt; size of output buffer"</span>]
    </span><span class="kw">pub </span>size: usize,
    <span class="attr">#[doc = <span class="string">"&lt; position where writing stopped. Will be updated. Necessarily 0 &lt;= pos &lt;= size"</span>]
    </span><span class="kw">pub </span>pos: usize,
}
<span class="kw">pub type </span>ZSTD_outBuffer = ZSTD_outBuffer_s;
<span class="kw">pub type </span>ZSTD_CStream = ZSTD_CCtx;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createCStream() -&gt; <span class="kw-2">*mut </span>ZSTD_CStream;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_freeCStream(zcs: <span class="kw-2">*mut </span>ZSTD_CStream) -&gt; usize;
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_EndDirective {
    ZSTD_e_continue = <span class="number">0</span>,
    ZSTD_e_flush = <span class="number">1</span>,
    ZSTD_e_end = <span class="number">2</span>,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compressStream2() : Requires v1.4.0+\n  Behaves about the same as ZSTD_compressStream, with additional control on end directive.\n  - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()\n  - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)\n  - output-&gt;pos must be &lt;= dstCapacity, input-&gt;pos must be &lt;= srcSize\n  - output-&gt;pos and input-&gt;pos will be updated. They are guaranteed to remain below their respective limit.\n  - endOp must be a valid directive\n  - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.\n  - When nbWorkers&gt;=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,\n                                                  and then immediately returns, just indicating that there is some data remaining to be flushed.\n                                                  The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.\n  - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.\n  - @return provides a minimum amount of data remaining to be flushed from internal buffers\n            or an error code, which can be tested using ZSTD_isError().\n            if @return != 0, flush is not fully completed, there is still some data left within internal buffers.\n            This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.\n            For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.\n  - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),\n            only ZSTD_e_end or ZSTD_e_flush operations are allowed.\n            Before starting a new compression job, or changing compression parameters,\n            it is required to fully flush internal buffers."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compressStream2(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        output: <span class="kw-2">*mut </span>ZSTD_outBuffer,
        input: <span class="kw-2">*mut </span>ZSTD_inBuffer,
        endOp: ZSTD_EndDirective,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_CStreamInSize() -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_CStreamOutSize() -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Equivalent to:\n\n     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);\n     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)\n     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);\n\n Note that ZSTD_initCStream() clears any previously set dictionary. Use the new API\n to compress with a dictionary."</span>]
    </span><span class="kw">pub fn </span>ZSTD_initCStream(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).\n NOTE: The return value is different. ZSTD_compressStream() returns a hint for\n the next read size (if non-zero and not an error). ZSTD_compressStream2()\n returns the minimum nb of bytes left to flush (if non-zero and not an error)."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compressStream(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        output: <span class="kw-2">*mut </span>ZSTD_outBuffer,
        input: <span class="kw-2">*mut </span>ZSTD_inBuffer,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Equivalent to ZSTD_compressStream2(zcs, output, &amp;emptyInput, ZSTD_e_flush)."</span>]
    </span><span class="kw">pub fn </span>ZSTD_flushStream(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        output: <span class="kw-2">*mut </span>ZSTD_outBuffer,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" Equivalent to ZSTD_compressStream2(zcs, output, &amp;emptyInput, ZSTD_e_end)."</span>]
    </span><span class="kw">pub fn </span>ZSTD_endStream(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        output: <span class="kw-2">*mut </span>ZSTD_outBuffer,
    ) -&gt; usize;
}
<span class="kw">pub type </span>ZSTD_DStream = ZSTD_DCtx;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createDStream() -&gt; <span class="kw-2">*mut </span>ZSTD_DStream;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_freeDStream(zds: <span class="kw-2">*mut </span>ZSTD_DStream) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_initDStream() :\n Initialize/reset DStream state for new decompression operation.\n Call before new decompression operation using same DStream.\n\n Note : This function is redundant with the advanced API and equivalent to:\n     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);\n     ZSTD_DCtx_refDDict(zds, NULL);"</span>]
    </span><span class="kw">pub fn </span>ZSTD_initDStream(zds: <span class="kw-2">*mut </span>ZSTD_DStream) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompressStream() :\n Streaming decompression function.\n Call repetitively to consume full input updating it as necessary.\n Function will update both input and output `pos` fields exposing current state via these fields:\n - `input.pos &lt; input.size`, some input remaining and caller should provide remaining input\n   on the next call.\n - `output.pos &lt; output.size`, decoder finished and flushed all remaining buffers.\n - `output.pos == output.size`, potentially uncflushed data present in the internal buffers,\n   call ZSTD_decompressStream() again to flush remaining data to output.\n Note : with no additional input, amount of data flushed &lt;= ZSTD_BLOCKSIZE_MAX.\n\n @return : 0 when a frame is completely decoded and fully flushed,\n           or an error code, which can be tested using ZSTD_isError(),\n           or any other value &gt; 0, which means there is some decoding or flushing to do to complete current frame."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompressStream(
        zds: <span class="kw-2">*mut </span>ZSTD_DStream,
        output: <span class="kw-2">*mut </span>ZSTD_outBuffer,
        input: <span class="kw-2">*mut </span>ZSTD_inBuffer,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_DStreamInSize() -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_DStreamOutSize() -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">"  Simple dictionary API\n/\n/*! ZSTD_compress_usingDict() :\n  Compression at an explicit compression level using a Dictionary.\n  A dictionary can be any arbitrary data segment (also called a prefix),\n  or a buffer with specified information (see zdict.h).\n  Note : This function loads the dictionary, resulting in significant startup delay.\n         It's intended for a dictionary used only once.\n  Note 2 : When `dict == NULL || dictSize &lt; 8` no dictionary is used."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compress_usingDict(
        ctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompress_usingDict() :\n  Decompression using a known Dictionary.\n  Dictionary must be identical to the one used during compression.\n  Note : This function loads the dictionary, resulting in significant startup delay.\n         It's intended for a dictionary used only once.\n  Note : When `dict == NULL || dictSize &lt; 8` no dictionary is used."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompress_usingDict(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; usize;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_CDict_s {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[doc = <span class="string">"  Bulk processing dictionary API"</span>]
</span><span class="kw">pub type </span>ZSTD_CDict = ZSTD_CDict_s;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_createCDict() :\n  When compressing multiple messages or blocks using the same dictionary,\n  it's recommended to digest the dictionary only once, since it's a costly operation.\n  ZSTD_createCDict() will create a state from digesting a dictionary.\n  The resulting state can be used for future compression operations with very limited startup cost.\n  ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.\n @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.\n  Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.\n  Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,\n      in which case the only thing that it transports is the @compressionLevel.\n      This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,\n      expecting a ZSTD_CDict parameter with any data, including those without a known dictionary."</span>]
    </span><span class="kw">pub fn </span>ZSTD_createCDict(
        dictBuffer: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CDict;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_freeCDict() :\n  Function frees memory allocated by ZSTD_createCDict().\n  If a NULL pointer is passed, no operation is performed."</span>]
    </span><span class="kw">pub fn </span>ZSTD_freeCDict(CDict: <span class="kw-2">*mut </span>ZSTD_CDict) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compress_usingCDict() :\n  Compression using a digested Dictionary.\n  Recommended when same dictionary is used multiple times.\n  Note : compression level is _decided at dictionary creation time_,\n     and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_compress_usingCDict(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
    ) -&gt; usize;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_DDict_s {
    _unused: [u8; <span class="number">0</span>],
}
<span class="kw">pub type </span>ZSTD_DDict = ZSTD_DDict_s;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_createDDict() :\n  Create a digested dictionary, ready to start decompression operation without startup delay.\n  dictBuffer can be released after DDict creation, as its content is copied inside DDict."</span>]
    </span><span class="kw">pub fn </span>ZSTD_createDDict(
        dictBuffer: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_DDict;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_freeDDict() :\n  Function frees memory allocated with ZSTD_createDDict()\n  If a NULL pointer is passed, no operation is performed."</span>]
    </span><span class="kw">pub fn </span>ZSTD_freeDDict(ddict: <span class="kw-2">*mut </span>ZSTD_DDict) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompress_usingDDict() :\n  Decompression using a digested Dictionary.\n  Recommended when same dictionary is used multiple times."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompress_usingDDict(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        ddict: <span class="kw-2">*const </span>ZSTD_DDict,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getDictID_fromDict() : Requires v1.4.0+\n  Provides the dictID stored within dictionary.\n  if @return == 0, the dictionary is not conformant with Zstandard specification.\n  It can still be loaded, but as a content-only dictionary."</span>]
    </span><span class="kw">pub fn </span>ZSTD_getDictID_fromDict(
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getDictID_fromCDict() : Requires v1.5.0+\n  Provides the dictID of the dictionary loaded into `cdict`.\n  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.\n  Non-conformant dictionaries can still be loaded, but as content-only dictionaries."</span>]
    </span><span class="kw">pub fn </span>ZSTD_getDictID_fromCDict(
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
    ) -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getDictID_fromDDict() : Requires v1.4.0+\n  Provides the dictID of the dictionary loaded into `ddict`.\n  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.\n  Non-conformant dictionaries can still be loaded, but as content-only dictionaries."</span>]
    </span><span class="kw">pub fn </span>ZSTD_getDictID_fromDDict(
        ddict: <span class="kw-2">*const </span>ZSTD_DDict,
    ) -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getDictID_fromFrame() : Requires v1.4.0+\n  Provides the dictID required to decompressed the frame stored within `src`.\n  If @return == 0, the dictID could not be decoded.\n  This could for one of the following reasons :\n  - The frame does not require a dictionary to be decoded (most common case).\n  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden piece of information.\n    Note : this use case also happens when using a non-conformant dictionary.\n  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize &lt; ZSTD_FRAMEHEADERSIZE_MAX`).\n  - This is not a Zstandard frame.\n  When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code."</span>]
    </span><span class="kw">pub fn </span>ZSTD_getDictID_fromFrame(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_loadDictionary() : Requires v1.4.0+\n  Create an internal CDict from `dict` buffer.\n  Decompression will have to use same dictionary.\n @result : 0, or an error code (which can be tested with ZSTD_isError()).\n  Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,\n           meaning \"return to no-dictionary mode\".\n  Note 1 : Dictionary is sticky, it will be used for all future compressed frames,\n           until parameters are reset, a new dictionary is loaded, or the dictionary\n           is explicitly invalidated by loading a NULL dictionary.\n  Note 2 : Loading a dictionary involves building tables.\n           It's also a CPU consuming operation, with non-negligible impact on latency.\n           Tables are dependent on compression parameters, and for this reason,\n           compression parameters can no longer be changed after loading a dictionary.\n  Note 3 :`dict` content will be copied internally.\n           Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.\n           In such a case, dictionary buffer must outlive its users.\n  Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()\n           to precisely select how dictionary content must be interpreted.\n  Note 5 : This method does not benefit from LDM (long distance mode).\n           If you want to employ LDM on some large dictionary content,\n           prefer employing ZSTD_CCtx_refPrefix() described below."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_loadDictionary(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_refCDict() : Requires v1.4.0+\n  Reference a prepared dictionary, to be used for all future compressed frames.\n  Note that compression parameters are enforced from within CDict,\n  and supersede any compression parameter previously set within CCtx.\n  The parameters ignored are labelled as \"superseded-by-cdict\" in the ZSTD_cParameter enum docs.\n  The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.\n  The dictionary will remain valid for future compressed frames using same CCtx.\n @result : 0, or an error code (which can be tested with ZSTD_isError()).\n  Special : Referencing a NULL CDict means \"return to no-dictionary mode\".\n  Note 1 : Currently, only one dictionary can be managed.\n           Referencing a new dictionary effectively \"discards\" any previous one.\n  Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_refCDict(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_refPrefix() : Requires v1.4.0+\n  Reference a prefix (single-usage dictionary) for next compressed frame.\n  A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).\n  Decompression will need same prefix to properly regenerate data.\n  Compressing with a prefix is similar in outcome as performing a diff and compressing it,\n  but performs much faster, especially during decompression (compression speed is tunable with compression level).\n  This method is compatible with LDM (long distance mode).\n @result : 0, or an error code (which can be tested with ZSTD_isError()).\n  Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary\n  Note 1 : Prefix buffer is referenced. It **must** outlive compression.\n           Its content must remain unmodified during compression.\n  Note 2 : If the intention is to diff some large src data blob with some prior version of itself,\n           ensure that the window size is large enough to contain the entire source.\n           See ZSTD_c_windowLog.\n  Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.\n           It's a CPU consuming operation, with non-negligible impact on latency.\n           If there is a need to use the same prefix multiple times, consider loadDictionary instead.\n  Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).\n           Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_refPrefix(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        prefix: <span class="kw-2">*const </span>::core::ffi::c_void,
        prefixSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_loadDictionary() : Requires v1.4.0+\n  Create an internal DDict from dict buffer, to be used to decompress all future frames.\n  The dictionary remains valid for all future frames, until explicitly invalidated, or\n  a new dictionary is loaded.\n @result : 0, or an error code (which can be tested with ZSTD_isError()).\n  Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,\n            meaning \"return to no-dictionary mode\".\n  Note 1 : Loading a dictionary involves building tables,\n           which has a non-negligible impact on CPU usage and latency.\n           It's recommended to \"load once, use many times\", to amortize the cost\n  Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.\n           Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.\n  Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of\n           how dictionary content is loaded and interpreted."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_loadDictionary(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_refDDict() : Requires v1.4.0+\n  Reference a prepared dictionary, to be used to decompress next frames.\n  The dictionary remains active for decompression of future frames using same DCtx.\n\n  If called with ZSTD_d_refMultipleDDicts enabled, repeated calls of this function\n  will store the DDict references in a table, and the DDict used for decompression\n  will be determined at decompression time, as per the dict ID in the frame.\n  The memory for the table is allocated on the first call to refDDict, and can be\n  freed with ZSTD_freeDCtx().\n\n  If called with ZSTD_d_refMultipleDDicts disabled (the default), only one dictionary\n  will be managed, and referencing a dictionary effectively \"discards\" any previous one.\n\n @result : 0, or an error code (which can be tested with ZSTD_isError()).\n  Special: referencing a NULL DDict means \"return to no-dictionary mode\".\n  Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_refDDict(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        ddict: <span class="kw-2">*const </span>ZSTD_DDict,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_refPrefix() : Requires v1.4.0+\n  Reference a prefix (single-usage dictionary) to decompress next frame.\n  This is the reverse operation of ZSTD_CCtx_refPrefix(),\n  and must use the same prefix as the one used during compression.\n  Prefix is **only used once**. Reference is discarded at end of frame.\n  End of frame is reached when ZSTD_decompressStream() returns 0.\n @result : 0, or an error code (which can be tested with ZSTD_isError()).\n  Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary\n  Note 2 : Prefix buffer is referenced. It **must** outlive decompression.\n           Prefix buffer must remain unmodified up to the end of frame,\n           reached when ZSTD_decompressStream() returns 0.\n  Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).\n           Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)\n  Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.\n           A full dictionary is more costly, as it requires building tables."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_refPrefix(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        prefix: <span class="kw-2">*const </span>::core::ffi::c_void,
        prefixSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_sizeof_*() : Requires v1.4.0+\n  These functions give the _current_ memory usage of selected object.\n  Note that object memory usage can evolve (increase or decrease) over time."</span>]
    </span><span class="kw">pub fn </span>ZSTD_sizeof_CCtx(cctx: <span class="kw-2">*const </span>ZSTD_CCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_sizeof_DCtx(dctx: <span class="kw-2">*const </span>ZSTD_DCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_sizeof_CStream(zcs: <span class="kw-2">*const </span>ZSTD_CStream) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_sizeof_DStream(zds: <span class="kw-2">*const </span>ZSTD_DStream) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_sizeof_CDict(cdict: <span class="kw-2">*const </span>ZSTD_CDict) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_sizeof_DDict(ddict: <span class="kw-2">*const </span>ZSTD_DDict) -&gt; usize;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_CCtx_params_s {
    _unused: [u8; <span class="number">0</span>],
}
<span class="kw">pub type </span>ZSTD_CCtx_params = ZSTD_CCtx_params_s;
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_Sequence {
    <span class="kw">pub </span>offset: ::core::ffi::c_uint,
    <span class="kw">pub </span>litLength: ::core::ffi::c_uint,
    <span class="kw">pub </span>matchLength: ::core::ffi::c_uint,
    <span class="kw">pub </span>rep: ::core::ffi::c_uint,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_compressionParameters {
    <span class="attr">#[doc = <span class="string">"&lt; largest match distance : larger == more compression, more memory needed during decompression"</span>]
    </span><span class="kw">pub </span>windowLog: ::core::ffi::c_uint,
    <span class="attr">#[doc = <span class="string">"&lt; fully searched segment : larger == more compression, slower, more memory (useless for fast)"</span>]
    </span><span class="kw">pub </span>chainLog: ::core::ffi::c_uint,
    <span class="attr">#[doc = <span class="string">"&lt; dispatch table : larger == faster, more memory"</span>]
    </span><span class="kw">pub </span>hashLog: ::core::ffi::c_uint,
    <span class="attr">#[doc = <span class="string">"&lt; nb of searches : larger == more compression, slower"</span>]
    </span><span class="kw">pub </span>searchLog: ::core::ffi::c_uint,
    <span class="attr">#[doc = <span class="string">"&lt; match length searched : larger == faster decompression, sometimes less compression"</span>]
    </span><span class="kw">pub </span>minMatch: ::core::ffi::c_uint,
    <span class="attr">#[doc = <span class="string">"&lt; acceptable match size for optimal parser (only) : larger == more compression, slower"</span>]
    </span><span class="kw">pub </span>targetLength: ::core::ffi::c_uint,
    <span class="attr">#[doc = <span class="string">"&lt; see ZSTD_strategy definition above"</span>]
    </span><span class="kw">pub </span>strategy: ZSTD_strategy,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_frameParameters {
    <span class="attr">#[doc = <span class="string">"&lt; 1: content size will be in frame header (when known)"</span>]
    </span><span class="kw">pub </span>contentSizeFlag: ::core::ffi::c_int,
    <span class="attr">#[doc = <span class="string">"&lt; 1: generate a 32-bits checksum using XXH64 algorithm at end of frame, for error detection"</span>]
    </span><span class="kw">pub </span>checksumFlag: ::core::ffi::c_int,
    <span class="attr">#[doc = <span class="string">"&lt; 1: no dictID will be saved into frame header (dictID is only useful for dictionary compression)"</span>]
    </span><span class="kw">pub </span>noDictIDFlag: ::core::ffi::c_int,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_parameters {
    <span class="kw">pub </span>cParams: ZSTD_compressionParameters,
    <span class="kw">pub </span>fParams: ZSTD_frameParameters,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_dictContentType_e {
    ZSTD_dct_auto = <span class="number">0</span>,
    ZSTD_dct_rawContent = <span class="number">1</span>,
    ZSTD_dct_fullDict = <span class="number">2</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_dictLoadMethod_e {
    <span class="attr">#[doc = <span class="string">"&lt; Copy dictionary content internally"</span>]
    </span>ZSTD_dlm_byCopy = <span class="number">0</span>,
    <span class="attr">#[doc = <span class="string">"&lt; Reference dictionary content -- the dictionary buffer must outlive its users."</span>]
    </span>ZSTD_dlm_byRef = <span class="number">1</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_format_e {
    ZSTD_f_zstd1 = <span class="number">0</span>,
    ZSTD_f_zstd1_magicless = <span class="number">1</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_forceIgnoreChecksum_e {
    ZSTD_d_validateChecksum = <span class="number">0</span>,
    ZSTD_d_ignoreChecksum = <span class="number">1</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_refMultipleDDicts_e {
    ZSTD_rmd_refSingleDDict = <span class="number">0</span>,
    ZSTD_rmd_refMultipleDDicts = <span class="number">1</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_dictAttachPref_e {
    ZSTD_dictDefaultAttach = <span class="number">0</span>,
    ZSTD_dictForceAttach = <span class="number">1</span>,
    ZSTD_dictForceCopy = <span class="number">2</span>,
    ZSTD_dictForceLoad = <span class="number">3</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_literalCompressionMode_e {
    <span class="attr">#[doc = <span class="string">"&lt; Automatically determine the compression mode based on the compression level.\n   Negative compression levels will be uncompressed, and positive compression\n   levels will be compressed."</span>]
    </span>ZSTD_lcm_auto = <span class="number">0</span>,
    <span class="attr">#[doc = <span class="string">"&lt; Always attempt Huffman compression. Uncompressed literals will still be\n   emitted if Huffman compression is not profitable."</span>]
    </span>ZSTD_lcm_huffman = <span class="number">1</span>,
    <span class="attr">#[doc = <span class="string">"&lt; Always emit uncompressed literals."</span>]
    </span>ZSTD_lcm_uncompressed = <span class="number">2</span>,
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_paramSwitch_e {
    ZSTD_ps_auto = <span class="number">0</span>,
    ZSTD_ps_enable = <span class="number">1</span>,
    ZSTD_ps_disable = <span class="number">2</span>,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_findDecompressedSize() :\n  `src` should point to the start of a series of ZSTD encoded and/or skippable frames\n  `srcSize` must be the _exact_ size of this series\n       (i.e. there should be a frame boundary at `src + srcSize`)\n  @return : - decompressed size of all data in all successive frames\n            - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN\n            - if an error occurred: ZSTD_CONTENTSIZE_ERROR\n\n   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.\n            When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size.\n            In which case, it's necessary to use streaming mode to decompress data.\n   note 2 : decompressed size is always present when compression is done with ZSTD_compress()\n   note 3 : decompressed size can be very large (64-bits value),\n            potentially larger than what local system can handle as a single memory segment.\n            In which case, it's necessary to use streaming mode to decompress data.\n   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.\n            Always ensure result fits within application's authorized limits.\n            Each application can set its own limits.\n   note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to\n            read each contained frame header.  This is fast as most of the data is skipped,\n            however it does mean that all frame data must be present and valid."</span>]
    </span><span class="kw">pub fn </span>ZSTD_findDecompressedSize(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; ::core::ffi::c_ulonglong;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompressBound() :\n  `src` should point to the start of a series of ZSTD encoded and/or skippable frames\n  `srcSize` must be the _exact_ size of this series\n       (i.e. there should be a frame boundary at `src + srcSize`)\n  @return : - upper-bound for the decompressed size of all data in all successive frames\n            - if an error occurred: ZSTD_CONTENTSIZE_ERROR\n\n  note 1  : an error can occur if `src` contains an invalid or incorrectly formatted frame.\n  note 2  : the upper-bound is exact when the decompressed size field is available in every ZSTD encoded frame of `src`.\n            in this case, `ZSTD_findDecompressedSize` and `ZSTD_decompressBound` return the same value.\n  note 3  : when the decompressed size field isn't available, the upper-bound for that frame is calculated by:\n              upper-bound = # blocks * min(128 KB, Window_Size)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompressBound(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; ::core::ffi::c_ulonglong;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_frameHeaderSize() :\n  srcSize must be &gt;= ZSTD_FRAMEHEADERSIZE_PREFIX.\n @return : size of the Frame Header,\n           or an error code (if srcSize is too small)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_frameHeaderSize(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_frameType_e {
    ZSTD_frame = <span class="number">0</span>,
    ZSTD_skippableFrame = <span class="number">1</span>,
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_frameHeader {
    <span class="kw">pub </span>frameContentSize: ::core::ffi::c_ulonglong,
    <span class="kw">pub </span>windowSize: ::core::ffi::c_ulonglong,
    <span class="kw">pub </span>blockSizeMax: ::core::ffi::c_uint,
    <span class="kw">pub </span>frameType: ZSTD_frameType_e,
    <span class="kw">pub </span>headerSize: ::core::ffi::c_uint,
    <span class="kw">pub </span>dictID: ::core::ffi::c_uint,
    <span class="kw">pub </span>checksumFlag: ::core::ffi::c_uint,
    <span class="kw">pub </span>_reserved1: ::core::ffi::c_uint,
    <span class="kw">pub </span>_reserved2: ::core::ffi::c_uint,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getFrameHeader() :\n  decode Frame Header, or requires larger `srcSize`.\n @return : 0, `zfhPtr` is correctly filled,\n          &gt;0, `srcSize` is too small, value is wanted `srcSize` amount,\n           or an error code, which can be tested using ZSTD_isError()"</span>]
    </span><span class="kw">pub fn </span>ZSTD_getFrameHeader(
        zfhPtr: <span class="kw-2">*mut </span>ZSTD_frameHeader,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getFrameHeader_advanced() :\n  same as ZSTD_getFrameHeader(),\n  with added capability to select a format (like ZSTD_f_zstd1_magicless)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_getFrameHeader_advanced(
        zfhPtr: <span class="kw-2">*mut </span>ZSTD_frameHeader,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        format: ZSTD_format_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompressionMargin() :\n Zstd supports in-place decompression, where the input and output buffers overlap.\n In this case, the output buffer must be at least (Margin + Output_Size) bytes large,\n and the input buffer must be at the end of the output buffer.\n\n  _______________________ Output Buffer ________________________\n |                                                              |\n |                                        ____ Input Buffer ____|\n |                                       |                      |\n v                                       v                      v\n |---------------------------------------|-----------|----------|\n ^                                                   ^          ^\n |___________________ Output_Size ___________________|_ Margin _|\n\n NOTE: See also ZSTD_DECOMPRESSION_MARGIN().\n NOTE: This applies only to single-pass decompression through ZSTD_decompress() or\n ZSTD_decompressDCtx().\n NOTE: This function supports multi-frame input.\n\n @param src The compressed frame(s)\n @param srcSize The size of the compressed frame(s)\n @returns The decompression margin or an error that can be checked with ZSTD_isError()."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompressionMargin(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_sequenceFormat_e {
    ZSTD_sf_noBlockDelimiters = <span class="number">0</span>,
    ZSTD_sf_explicitBlockDelimiters = <span class="number">1</span>,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_sequenceBound() :\n `srcSize` : size of the input buffer\n  @return : upper-bound for the number of sequences that can be generated\n            from a buffer of srcSize bytes\n\n  note : returns number of sequences - to get bytes, multiply by sizeof(ZSTD_Sequence)."</span>]
    </span><span class="kw">pub fn </span>ZSTD_sequenceBound(srcSize: usize) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_generateSequences() :\n Generate sequences using ZSTD_compress2(), given a source buffer.\n\n Each block will end with a dummy sequence\n with offset == 0, matchLength == 0, and litLength == length of last literals.\n litLength may be == 0, and if so, then the sequence of (of: 0 ml: 0 ll: 0)\n simply acts as a block delimiter.\n\n @zc can be used to insert custom compression params.\n This function invokes ZSTD_compress2().\n\n The output of this function can be fed into ZSTD_compressSequences() with CCtx\n setting of ZSTD_c_blockDelimiters as ZSTD_sf_explicitBlockDelimiters\n @return : number of sequences generated"</span>]
    </span><span class="kw">pub fn </span>ZSTD_generateSequences(
        zc: <span class="kw-2">*mut </span>ZSTD_CCtx,
        outSeqs: <span class="kw-2">*mut </span>ZSTD_Sequence,
        outSeqsSize: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_mergeBlockDelimiters() :\n Given an array of ZSTD_Sequence, remove all sequences that represent block delimiters/last literals\n by merging them into the literals of the next sequence.\n\n As such, the final generated result has no explicit representation of block boundaries,\n and the final last literals segment is not represented in the sequences.\n\n The output of this function can be fed into ZSTD_compressSequences() with CCtx\n setting of ZSTD_c_blockDelimiters as ZSTD_sf_noBlockDelimiters\n @return : number of sequences left after merging"</span>]
    </span><span class="kw">pub fn </span>ZSTD_mergeBlockDelimiters(
        sequences: <span class="kw-2">*mut </span>ZSTD_Sequence,
        seqsSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compressSequences() :\n Compress an array of ZSTD_Sequence, associated with @src buffer, into dst.\n @src contains the entire input (not just the literals).\n If @srcSize &gt; sum(sequence.length), the remaining bytes are considered all literals\n If a dictionary is included, then the cctx should reference the dict. (see: ZSTD_CCtx_refCDict(), ZSTD_CCtx_loadDictionary(), etc.)\n The entire source is compressed into a single frame.\n\n The compression behavior changes based on cctx params. In particular:\n    If ZSTD_c_blockDelimiters == ZSTD_sf_noBlockDelimiters, the array of ZSTD_Sequence is expected to contain\n    no block delimiters (defined in ZSTD_Sequence). Block boundaries are roughly determined based on\n    the block size derived from the cctx, and sequences may be split. This is the default setting.\n\n    If ZSTD_c_blockDelimiters == ZSTD_sf_explicitBlockDelimiters, the array of ZSTD_Sequence is expected to contain\n    block delimiters (defined in ZSTD_Sequence). Behavior is undefined if no block delimiters are provided.\n\n    If ZSTD_c_validateSequences == 0, this function will blindly accept the sequences provided. Invalid sequences cause undefined\n    behavior. If ZSTD_c_validateSequences == 1, then if sequence is invalid (see doc/zstd_compression_format.md for\n    specifics regarding offset/matchlength requirements) then the function will bail out and return an error.\n\n    In addition to the two adjustable experimental params, there are other important cctx params.\n    - ZSTD_c_minMatch MUST be set as less than or equal to the smallest match generated by the match finder. It has a minimum value of ZSTD_MINMATCH_MIN.\n    - ZSTD_c_compressionLevel accordingly adjusts the strength of the entropy coder, as it would in typical compression.\n    - ZSTD_c_windowLog affects offset validation: this function will return an error at higher debug levels if a provided offset\n      is larger than what the spec allows for a given window log and dictionary (if present). See: doc/zstd_compression_format.md\n\n Note: Repcodes are, as of now, always re-calculated within this function, so ZSTD_Sequence::rep is unused.\n Note 2: Once we integrate ability to ingest repcodes, the explicit block delims mode must respect those repcodes exactly,\n         and cannot emit an RLE block that disagrees with the repcode history\n @return : final compressed size, or a ZSTD error code."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compressSequences(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstSize: usize,
        inSeqs: <span class="kw-2">*const </span>ZSTD_Sequence,
        inSeqsSize: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_writeSkippableFrame() :\n Generates a zstd skippable frame containing data given by src, and writes it to dst buffer.\n\n Skippable frames begin with a 4-byte magic number. There are 16 possible choices of magic number,\n ranging from ZSTD_MAGIC_SKIPPABLE_START to ZSTD_MAGIC_SKIPPABLE_START+15.\n As such, the parameter magicVariant controls the exact skippable frame magic number variant used, so\n the magic number used will be ZSTD_MAGIC_SKIPPABLE_START + magicVariant.\n\n Returns an error if destination buffer is not large enough, if the source size is not representable\n with a 4-byte unsigned int, or if the parameter magicVariant is greater than 15 (and therefore invalid).\n\n @return : number of bytes written or a ZSTD error."</span>]
    </span><span class="kw">pub fn </span>ZSTD_writeSkippableFrame(
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        magicVariant: ::core::ffi::c_uint,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_readSkippableFrame() :\n Retrieves a zstd skippable frame containing data given by src, and writes it to dst buffer.\n\n The parameter magicVariant will receive the magicVariant that was supplied when the frame was written,\n i.e. magicNumber - ZSTD_MAGIC_SKIPPABLE_START.  This can be NULL if the caller is not interested\n in the magicVariant.\n\n Returns an error if destination buffer is not large enough, or if the frame is not skippable.\n\n @return : number of bytes written or a ZSTD error."</span>]
    </span><span class="kw">pub fn </span>ZSTD_readSkippableFrame(
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        magicVariant: <span class="kw-2">*mut </span>::core::ffi::c_uint,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_isSkippableFrame() :\n  Tells if the content of `buffer` starts with a valid Frame Identifier for a skippable frame."</span>]
    </span><span class="kw">pub fn </span>ZSTD_isSkippableFrame(
        buffer: <span class="kw-2">*const </span>::core::ffi::c_void,
        size: usize,
    ) -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_estimate*() :\n  These functions make it possible to estimate memory usage\n  of a future {D,C}Ctx, before its creation.\n\n  ZSTD_estimateCCtxSize() will provide a memory budget large enough\n  for any compression level up to selected one.\n  Note : Unlike ZSTD_estimateCStreamSize*(), this estimate\n         does not include space for a window buffer.\n         Therefore, the estimation is only guaranteed for single-shot compressions, not streaming.\n  The estimate will assume the input may be arbitrarily large,\n  which is the worst case.\n\n  When srcSize can be bound by a known and rather \"small\" value,\n  this fact can be used to provide a tighter estimation\n  because the CCtx compression context will need less memory.\n  This tighter estimation can be provided by more advanced functions\n  ZSTD_estimateCCtxSize_usingCParams(), which can be used in tandem with ZSTD_getCParams(),\n  and ZSTD_estimateCCtxSize_usingCCtxParams(), which can be used in tandem with ZSTD_CCtxParams_setParameter().\n  Both can be used to estimate memory using custom compression parameters and arbitrary srcSize limits.\n\n  Note : only single-threaded compression is supported.\n  ZSTD_estimateCCtxSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is &gt;= 1.\n\n  Note 2 : ZSTD_estimateCCtxSize* functions are not compatible with the Block-Level Sequence Producer API at this time.\n  Size estimates assume that no external sequence producer is registered."</span>]
    </span><span class="kw">pub fn </span>ZSTD_estimateCCtxSize(
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateCCtxSize_usingCParams(
        cParams: ZSTD_compressionParameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateCCtxSize_usingCCtxParams(
        params: <span class="kw-2">*const </span>ZSTD_CCtx_params,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateDCtxSize() -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_estimateCStreamSize() :\n  ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one.\n  It will also consider src size to be arbitrarily \"large\", which is worst case.\n  If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation.\n  ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel.\n  ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is &gt;= 1.\n  Note : CStream size estimation is only correct for single-threaded compression.\n  ZSTD_DStream memory budget depends on window Size.\n  This information can be passed manually, using ZSTD_estimateDStreamSize,\n  or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame();\n  Note : if streaming is init with function ZSTD_init?Stream_usingDict(),\n         an internal ?Dict will be created, which additional size is not estimated here.\n         In this case, get total size by adding ZSTD_estimate?DictSize\n  Note 2 : only single-threaded compression is supported.\n  ZSTD_estimateCStreamSize_usingCCtxParams() will return an error code if ZSTD_c_nbWorkers is &gt;= 1.\n  Note 3 : ZSTD_estimateCStreamSize* functions are not compatible with the Block-Level Sequence Producer API at this time.\n  Size estimates assume that no external sequence producer is registered."</span>]
    </span><span class="kw">pub fn </span>ZSTD_estimateCStreamSize(
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateCStreamSize_usingCParams(
        cParams: ZSTD_compressionParameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateCStreamSize_usingCCtxParams(
        params: <span class="kw-2">*const </span>ZSTD_CCtx_params,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateDStreamSize(windowSize: usize) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateDStreamSize_fromFrame(
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_estimate?DictSize() :\n  ZSTD_estimateCDictSize() will bet that src size is relatively \"small\", and content is copied, like ZSTD_createCDict().\n  ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced().\n  Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller."</span>]
    </span><span class="kw">pub fn </span>ZSTD_estimateCDictSize(
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateCDictSize_advanced(
        dictSize: usize,
        cParams: ZSTD_compressionParameters,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_estimateDDictSize(
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_initStatic*() :\n  Initialize an object using a pre-allocated fixed-size buffer.\n  workspace: The memory area to emplace the object into.\n             Provided pointer *must be 8-bytes aligned*.\n             Buffer must outlive object.\n  workspaceSize: Use ZSTD_estimate*Size() to determine\n                 how large workspace must be to support target scenario.\n @return : pointer to object (same address as workspace, just different type),\n           or NULL if error (size too small, incorrect alignment, etc.)\n  Note : zstd will never resize nor malloc() when using a static buffer.\n         If the object requires more memory than available,\n         zstd will just error out (typically ZSTD_error_memory_allocation).\n  Note 2 : there is no corresponding \"free\" function.\n           Since workspace is allocated externally, it must be freed externally too.\n  Note 3 : cParams : use ZSTD_getCParams() to convert a compression level\n           into its associated cParams.\n  Limitation 1 : currently not compatible with internal dictionary creation, triggered by\n                 ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict().\n  Limitation 2 : static cctx currently not compatible with multi-threading.\n  Limitation 3 : static dctx is incompatible with legacy support."</span>]
    </span><span class="kw">pub fn </span>ZSTD_initStaticCCtx(
        workspace: <span class="kw-2">*mut </span>::core::ffi::c_void,
        workspaceSize: usize,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CCtx;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_initStaticCStream(
        workspace: <span class="kw-2">*mut </span>::core::ffi::c_void,
        workspaceSize: usize,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CStream;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_initStaticDCtx(
        workspace: <span class="kw-2">*mut </span>::core::ffi::c_void,
        workspaceSize: usize,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_DCtx;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_initStaticDStream(
        workspace: <span class="kw-2">*mut </span>::core::ffi::c_void,
        workspaceSize: usize,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_DStream;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_initStaticCDict(
        workspace: <span class="kw-2">*mut </span>::core::ffi::c_void,
        workspaceSize: usize,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
        cParams: ZSTD_compressionParameters,
    ) -&gt; <span class="kw-2">*const </span>ZSTD_CDict;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_initStaticDDict(
        workspace: <span class="kw-2">*mut </span>::core::ffi::c_void,
        workspaceSize: usize,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
    ) -&gt; <span class="kw-2">*const </span>ZSTD_DDict;
}
<span class="attr">#[doc = <span class="string">" Custom memory allocation :\n  These prototypes make it possible to pass your own allocation/free functions.\n  ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below.\n  All allocation/free operations will be completed using these custom variants instead of regular &lt;stdlib.h&gt; ones."</span>]
</span><span class="kw">pub type </span>ZSTD_allocFunction = ::core::option::Option&lt;
    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
        opaque: <span class="kw-2">*mut </span>::core::ffi::c_void,
        size: usize,
    ) -&gt; <span class="kw-2">*mut </span>::core::ffi::c_void,
&gt;;
<span class="kw">pub type </span>ZSTD_freeFunction = ::core::option::Option&lt;
    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
        opaque: <span class="kw-2">*mut </span>::core::ffi::c_void,
        address: <span class="kw-2">*mut </span>::core::ffi::c_void,
    ),
&gt;;
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_customMem {
    <span class="kw">pub </span>customAlloc: ZSTD_allocFunction,
    <span class="kw">pub </span>customFree: ZSTD_freeFunction,
    <span class="kw">pub </span>opaque: <span class="kw-2">*mut </span>::core::ffi::c_void,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">"&lt; this constant defers to stdlib's functions"</span>]
    </span><span class="kw">pub static </span>ZSTD_defaultCMem: ZSTD_customMem;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createCCtx_advanced(
        customMem: ZSTD_customMem,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CCtx;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createCStream_advanced(
        customMem: ZSTD_customMem,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CStream;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createDCtx_advanced(
        customMem: ZSTD_customMem,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_DCtx;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createDStream_advanced(
        customMem: ZSTD_customMem,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_DStream;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createCDict_advanced(
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
        cParams: ZSTD_compressionParameters,
        customMem: ZSTD_customMem,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CDict;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>POOL_ctx_s {
    _unused: [u8; <span class="number">0</span>],
}
<span class="attr">#[doc = <span class="string">" Thread pool :\n  These prototypes make it possible to share a thread pool among multiple compression contexts.\n  This can limit resources for applications with multiple threads where each one uses\n  a threaded compression mode (via ZSTD_c_nbWorkers parameter).\n  ZSTD_createThreadPool creates a new thread pool with a given number of threads.\n  Note that the lifetime of such pool must exist while being used.\n  ZSTD_CCtx_refThreadPool assigns a thread pool to a context (use NULL argument value\n  to use an internal thread pool).\n  ZSTD_freeThreadPool frees a thread pool, accepts NULL pointer."</span>]
</span><span class="kw">pub type </span>ZSTD_threadPool = POOL_ctx_s;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createThreadPool(numThreads: usize) -&gt; <span class="kw-2">*mut </span>ZSTD_threadPool;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_freeThreadPool(pool: <span class="kw-2">*mut </span>ZSTD_threadPool);
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_CCtx_refThreadPool(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        pool: <span class="kw-2">*mut </span>ZSTD_threadPool,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createCDict_advanced2(
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
        cctxParams: <span class="kw-2">*const </span>ZSTD_CCtx_params,
        customMem: ZSTD_customMem,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CDict;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_createDDict_advanced(
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
        customMem: ZSTD_customMem,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_DDict;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_createCDict_byReference() :\n  Create a digested dictionary for compression\n  Dictionary content is just referenced, not duplicated.\n  As a consequence, `dictBuffer` **must** outlive CDict,\n  and its content must remain unmodified throughout the lifetime of CDict.\n  note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef"</span>]
    </span><span class="kw">pub fn </span>ZSTD_createCDict_byReference(
        dictBuffer: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_CDict;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getCParams() :\n @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize.\n `estimatedSrcSize` value is optional, select 0 if not known"</span>]
    </span><span class="kw">pub fn </span>ZSTD_getCParams(
        compressionLevel: ::core::ffi::c_int,
        estimatedSrcSize: ::core::ffi::c_ulonglong,
        dictSize: usize,
    ) -&gt; ZSTD_compressionParameters;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getParams() :\n  same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`.\n  All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0"</span>]
    </span><span class="kw">pub fn </span>ZSTD_getParams(
        compressionLevel: ::core::ffi::c_int,
        estimatedSrcSize: ::core::ffi::c_ulonglong,
        dictSize: usize,
    ) -&gt; ZSTD_parameters;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_checkCParams() :\n  Ensure param values remain within authorized range.\n @return 0 on success, or an error code (can be checked with ZSTD_isError())"</span>]
    </span><span class="kw">pub fn </span>ZSTD_checkCParams(params: ZSTD_compressionParameters) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_adjustCParams() :\n  optimize params for a given `srcSize` and `dictSize`.\n `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN.\n `dictSize` must be `0` when there is no dictionary.\n  cPar can be invalid : all parameters will be clamped within valid range in the @return struct.\n  This function never fails (wide contract)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_adjustCParams(
        cPar: ZSTD_compressionParameters,
        srcSize: ::core::ffi::c_ulonglong,
        dictSize: usize,
    ) -&gt; ZSTD_compressionParameters;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_setCParams() :\n  Set all parameters provided within @p cparams into the working @p cctx.\n  Note : if modifying parameters during compression (MT mode only),\n         note that changes to the .windowLog parameter will be ignored.\n @return 0 on success, or an error code (can be checked with ZSTD_isError()).\n         On failure, no parameters are updated."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_setCParams(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        cparams: ZSTD_compressionParameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_setFParams() :\n  Set all parameters provided within @p fparams into the working @p cctx.\n @return 0 on success, or an error code (can be checked with ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_setFParams(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        fparams: ZSTD_frameParameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_setParams() :\n  Set all parameters provided within @p params into the working @p cctx.\n @return 0 on success, or an error code (can be checked with ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_setParams(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        params: ZSTD_parameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compress_advanced() :\n  Note : this function is now DEPRECATED.\n         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_setParameter() and other parameter setters.\n  This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compress_advanced(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        params: ZSTD_parameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compress_usingCDict_advanced() :\n  Note : this function is now DEPRECATED.\n         It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters.\n  This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compress_usingCDict_advanced(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
        fParams: ZSTD_frameParameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_loadDictionary_byReference() :\n  Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx.\n  It saves some memory, but also requires that `dict` outlives its usage within `cctx`"</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_loadDictionary_byReference(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_loadDictionary_advanced() :\n  Same as ZSTD_CCtx_loadDictionary(), but gives finer control over\n  how to load the dictionary (by copy ? by reference ?)\n  and how to interpret it (automatic ? force raw mode ? full mode only ?)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_loadDictionary_advanced(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_refPrefix_advanced() :\n  Same as ZSTD_CCtx_refPrefix(), but gives finer control over\n  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_refPrefix_advanced(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        prefix: <span class="kw-2">*const </span>::core::ffi::c_void,
        prefixSize: usize,
        dictContentType: ZSTD_dictContentType_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_getParameter() :\n  Get the requested compression parameter value, selected by enum ZSTD_cParameter,\n  and store it into int* value.\n @return : 0, or an error code (which can be tested with ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_getParameter(
        cctx: <span class="kw-2">*const </span>ZSTD_CCtx,
        param: ZSTD_cParameter,
        value: <span class="kw-2">*mut </span>::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_params :\n  Quick howto :\n  - ZSTD_createCCtxParams() : Create a ZSTD_CCtx_params structure\n  - ZSTD_CCtxParams_setParameter() : Push parameters one by one into\n                                     an existing ZSTD_CCtx_params structure.\n                                     This is similar to\n                                     ZSTD_CCtx_setParameter().\n  - ZSTD_CCtx_setParametersUsingCCtxParams() : Apply parameters to\n                                    an existing CCtx.\n                                    These parameters will be applied to\n                                    all subsequent frames.\n  - ZSTD_compressStream2() : Do compression using the CCtx.\n  - ZSTD_freeCCtxParams() : Free the memory, accept NULL pointer.\n\n  This can be used with ZSTD_estimateCCtxSize_advanced_usingCCtxParams()\n  for static allocation of CCtx for single-threaded compression."</span>]
    </span><span class="kw">pub fn </span>ZSTD_createCCtxParams() -&gt; <span class="kw-2">*mut </span>ZSTD_CCtx_params;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_freeCCtxParams(params: <span class="kw-2">*mut </span>ZSTD_CCtx_params) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtxParams_reset() :\n  Reset params to default values."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtxParams_reset(params: <span class="kw-2">*mut </span>ZSTD_CCtx_params) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtxParams_init() :\n  Initializes the compression parameters of cctxParams according to\n  compression level. All other parameters are reset to their default values."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtxParams_init(
        cctxParams: <span class="kw-2">*mut </span>ZSTD_CCtx_params,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtxParams_init_advanced() :\n  Initializes the compression and frame parameters of cctxParams according to\n  params. All other parameters are reset to their default values."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtxParams_init_advanced(
        cctxParams: <span class="kw-2">*mut </span>ZSTD_CCtx_params,
        params: ZSTD_parameters,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtxParams_setParameter() : Requires v1.4.0+\n  Similar to ZSTD_CCtx_setParameter.\n  Set one compression parameter, selected by enum ZSTD_cParameter.\n  Parameters must be applied to a ZSTD_CCtx using\n  ZSTD_CCtx_setParametersUsingCCtxParams().\n @result : a code representing success or failure (which can be tested with\n           ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtxParams_setParameter(
        params: <span class="kw-2">*mut </span>ZSTD_CCtx_params,
        param: ZSTD_cParameter,
        value: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtxParams_getParameter() :\n Similar to ZSTD_CCtx_getParameter.\n Get the requested value of one compression parameter, selected by enum ZSTD_cParameter.\n @result : 0, or an error code (which can be tested with ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtxParams_getParameter(
        params: <span class="kw-2">*const </span>ZSTD_CCtx_params,
        param: ZSTD_cParameter,
        value: <span class="kw-2">*mut </span>::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_CCtx_setParametersUsingCCtxParams() :\n  Apply a set of ZSTD_CCtx_params to the compression context.\n  This can be done even after compression is started,\n    if nbWorkers==0, this will have no impact until a new compression is started.\n    if nbWorkers&gt;=1, new parameters will be picked up at next job,\n       with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated)."</span>]
    </span><span class="kw">pub fn </span>ZSTD_CCtx_setParametersUsingCCtxParams(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        params: <span class="kw-2">*const </span>ZSTD_CCtx_params,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_compressStream2_simpleArgs() :\n  Same as ZSTD_compressStream2(),\n  but using only integral types as arguments.\n  This variant might be helpful for binders from dynamic languages\n  which have troubles handling structures containing memory pointers."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compressStream2_simpleArgs(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        dstPos: <span class="kw-2">*mut </span>usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        srcPos: <span class="kw-2">*mut </span>usize,
        endOp: ZSTD_EndDirective,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_isFrame() :\n  Tells if the content of `buffer` starts with a valid Frame Identifier.\n  Note : Frame Identifier is 4 bytes. If `size &lt; 4`, @return will always be 0.\n  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.\n  Note 3 : Skippable Frame Identifiers are considered valid."</span>]
    </span><span class="kw">pub fn </span>ZSTD_isFrame(
        buffer: <span class="kw-2">*const </span>::core::ffi::c_void,
        size: usize,
    ) -&gt; ::core::ffi::c_uint;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_createDDict_byReference() :\n  Create a digested dictionary, ready to start decompression operation without startup delay.\n  Dictionary content is referenced, and therefore stays in dictBuffer.\n  It is important that dictBuffer outlives DDict,\n  it must remain read accessible throughout the lifetime of DDict"</span>]
    </span><span class="kw">pub fn </span>ZSTD_createDDict_byReference(
        dictBuffer: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; <span class="kw-2">*mut </span>ZSTD_DDict;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_loadDictionary_byReference() :\n  Same as ZSTD_DCtx_loadDictionary(),\n  but references `dict` content instead of copying it into `dctx`.\n  This saves memory if `dict` remains around.,\n  However, it's imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_loadDictionary_byReference(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_loadDictionary_advanced() :\n  Same as ZSTD_DCtx_loadDictionary(),\n  but gives direct control over\n  how to load the dictionary (by copy ? by reference ?)\n  and how to interpret it (automatic ? force raw mode ? full mode only ?)."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_loadDictionary_advanced(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        dictLoadMethod: ZSTD_dictLoadMethod_e,
        dictContentType: ZSTD_dictContentType_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_refPrefix_advanced() :\n  Same as ZSTD_DCtx_refPrefix(), but gives finer control over\n  how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_refPrefix_advanced(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        prefix: <span class="kw-2">*const </span>::core::ffi::c_void,
        prefixSize: usize,
        dictContentType: ZSTD_dictContentType_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_setMaxWindowSize() :\n  Refuses allocating internal buffers for frames requiring a window size larger than provided limit.\n  This protects a decoder context from reserving too much memory for itself (potential attack scenario).\n  This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode.\n  By default, a decompression context accepts all window sizes &lt;= (1 &lt;&lt; ZSTD_WINDOWLOG_LIMIT_DEFAULT)\n @return : 0, or an error code (which can be tested using ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_setMaxWindowSize(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        maxWindowSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_getParameter() :\n  Get the requested decompression parameter value, selected by enum ZSTD_dParameter,\n  and store it into int* value.\n @return : 0, or an error code (which can be tested with ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_getParameter(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        param: ZSTD_dParameter,
        value: <span class="kw-2">*mut </span>::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_DCtx_setFormat() :\n  This function is REDUNDANT. Prefer ZSTD_DCtx_setParameter().\n  Instruct the decoder context about what kind of data to decode next.\n  This instruction is mandatory to decode data without a fully-formed header,\n  such ZSTD_f_zstd1_magicless for example.\n @return : 0, or an error code (which can be tested using ZSTD_isError())."</span>]
    </span><span class="kw">pub fn </span>ZSTD_DCtx_setFormat(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        format: ZSTD_format_e,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_decompressStream_simpleArgs() :\n  Same as ZSTD_decompressStream(),\n  but using only integral types as arguments.\n  This can be helpful for binders from dynamic languages\n  which have troubles handling structures containing memory pointers."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decompressStream_simpleArgs(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        dstPos: <span class="kw-2">*mut </span>usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        srcPos: <span class="kw-2">*mut </span>usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_initCStream_srcSize() :\n This function is DEPRECATED, and equivalent to:\n     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);\n     ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)\n     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);\n     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);\n\n pledgedSrcSize must be correct. If it is not known at init time, use\n ZSTD_CONTENTSIZE_UNKNOWN. Note that, for compatibility with older programs,\n \"0\" also disables frame content size field. It may be enabled in the future.\n This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_initCStream_srcSize(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        compressionLevel: ::core::ffi::c_int,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_initCStream_usingDict() :\n This function is DEPRECATED, and is equivalent to:\n     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);\n     ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);\n     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);\n\n Creates of an internal CDict (incompatible with static CCtx), except if\n dict == NULL or dictSize &lt; 8, in which case no dict is used.\n Note: dict is loaded with ZSTD_dct_auto (treated as a full zstd dictionary if\n it begins with ZSTD_MAGIC_DICTIONARY, else as raw content) and ZSTD_dlm_byCopy.\n This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_initCStream_usingDict(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_initCStream_advanced() :\n This function is DEPRECATED, and is equivalent to:\n     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);\n     ZSTD_CCtx_setParams(zcs, params);\n     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);\n     ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);\n\n dict is loaded with ZSTD_dct_auto and ZSTD_dlm_byCopy.\n pledgedSrcSize must be correct.\n If srcSize is not known at init time, use value ZSTD_CONTENTSIZE_UNKNOWN.\n This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_initCStream_advanced(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        params: ZSTD_parameters,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_initCStream_usingCDict() :\n This function is DEPRECATED, and equivalent to:\n     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);\n     ZSTD_CCtx_refCDict(zcs, cdict);\n\n note : cdict will just be referenced, and must outlive compression session\n This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_initCStream_usingCDict(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_initCStream_usingCDict_advanced() :\n   This function is DEPRECATED, and is equivalent to:\n     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);\n     ZSTD_CCtx_setFParams(zcs, fParams);\n     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);\n     ZSTD_CCtx_refCDict(zcs, cdict);\n\n same as ZSTD_initCStream_usingCDict(), with control over frame parameters.\n pledgedSrcSize must be correct. If srcSize is not known at init time, use\n value ZSTD_CONTENTSIZE_UNKNOWN.\n This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_initCStream_usingCDict_advanced(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
        fParams: ZSTD_frameParameters,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_resetCStream() :\n This function is DEPRECATED, and is equivalent to:\n     ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);\n     ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);\n Note: ZSTD_resetCStream() interprets pledgedSrcSize == 0 as ZSTD_CONTENTSIZE_UNKNOWN, but\n       ZSTD_CCtx_setPledgedSrcSize() does not do the same, so ZSTD_CONTENTSIZE_UNKNOWN must be\n       explicitly specified.\n\n  start a new frame, using same parameters from previous frame.\n  This is typically useful to skip dictionary loading stage, since it will re-use it in-place.\n  Note that zcs must be init at least once before using ZSTD_resetCStream().\n  If pledgedSrcSize is not known at reset time, use macro ZSTD_CONTENTSIZE_UNKNOWN.\n  If pledgedSrcSize &gt; 0, its value must be correct, as it will be written in header, and controlled at the end.\n  For the time being, pledgedSrcSize==0 is interpreted as \"srcSize unknown\" for compatibility with older programs,\n  but it will change to mean \"empty\" in future version, so use macro ZSTD_CONTENTSIZE_UNKNOWN instead.\n @return : 0, or an error code (which can be tested using ZSTD_isError())\n  This prototype will generate compilation warnings."</span>]
    </span><span class="kw">pub fn </span>ZSTD_resetCStream(
        zcs: <span class="kw-2">*mut </span>ZSTD_CStream,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="attr">#[repr(C)]
#[derive(Debug, Copy, Clone)]
</span><span class="kw">pub struct </span>ZSTD_frameProgression {
    <span class="kw">pub </span>ingested: ::core::ffi::c_ulonglong,
    <span class="kw">pub </span>consumed: ::core::ffi::c_ulonglong,
    <span class="kw">pub </span>produced: ::core::ffi::c_ulonglong,
    <span class="kw">pub </span>flushed: ::core::ffi::c_ulonglong,
    <span class="kw">pub </span>currentJobID: ::core::ffi::c_uint,
    <span class="kw">pub </span>nbActiveWorkers: ::core::ffi::c_uint,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_getFrameProgression(
        cctx: <span class="kw-2">*const </span>ZSTD_CCtx,
    ) -&gt; ZSTD_frameProgression;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_toFlushNow() :\n  Tell how many bytes are ready to be flushed immediately.\n  Useful for multithreading scenarios (nbWorkers &gt;= 1).\n  Probe the oldest active job, defined as oldest job not yet entirely flushed,\n  and check its output buffer.\n @return : amount of data stored in oldest job and ready to be flushed immediately.\n  if @return == 0, it means either :\n  + there is no active job (could be checked with ZSTD_frameProgression()), or\n  + oldest job is still actively compressing data,\n    but everything it has produced has also been flushed so far,\n    therefore flush speed is limited by production speed of oldest job\n    irrespective of the speed of concurrent (and newer) jobs."</span>]
    </span><span class="kw">pub fn </span>ZSTD_toFlushNow(cctx: <span class="kw-2">*mut </span>ZSTD_CCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" This function is deprecated, and is equivalent to:\n\n     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);\n     ZSTD_DCtx_loadDictionary(zds, dict, dictSize);\n\n note: no dictionary will be used if dict == NULL or dictSize &lt; 8"</span>]
    </span><span class="kw">pub fn </span>ZSTD_initDStream_usingDict(
        zds: <span class="kw-2">*mut </span>ZSTD_DStream,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" This function is deprecated, and is equivalent to:\n\n     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);\n     ZSTD_DCtx_refDDict(zds, ddict);\n\n note : ddict is referenced, it must outlive decompression session"</span>]
    </span><span class="kw">pub fn </span>ZSTD_initDStream_usingDDict(
        zds: <span class="kw-2">*mut </span>ZSTD_DStream,
        ddict: <span class="kw-2">*const </span>ZSTD_DDict,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" This function is deprecated, and is equivalent to:\n\n     ZSTD_DCtx_reset(zds, ZSTD_reset_session_only);\n\n re-use decompression parameters from previous init; saves dictionary loading"</span>]
    </span><span class="kw">pub fn </span>ZSTD_resetDStream(zds: <span class="kw-2">*mut </span>ZSTD_DStream) -&gt; usize;
}
<span class="kw">pub type </span>ZSTD_sequenceProducer_F = ::core::option::Option&lt;
    <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn</span>(
        sequenceProducerState: <span class="kw-2">*mut </span>::core::ffi::c_void,
        outSeqs: <span class="kw-2">*mut </span>ZSTD_Sequence,
        outSeqsCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
        windowSize: usize,
    ) -&gt; usize,
&gt;;
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_registerSequenceProducer() :\n Instruct zstd to use a block-level external sequence producer function.\n\n The sequenceProducerState must be initialized by the caller, and the caller is\n responsible for managing its lifetime. This parameter is sticky across\n compressions. It will remain set until the user explicitly resets compression\n parameters.\n\n Sequence producer registration is considered to be an \"advanced parameter\",\n part of the \"advanced API\". This means it will only have an effect on compression\n APIs which respect advanced parameters, such as compress2() and compressStream2().\n Older compression APIs such as compressCCtx(), which predate the introduction of\n \"advanced parameters\", will ignore any external sequence producer setting.\n\n The sequence producer can be \"cleared\" by registering a NULL function pointer. This\n removes all limitations described above in the \"LIMITATIONS\" section of the API docs.\n\n The user is strongly encouraged to read the full API documentation (above) before\n calling this function."</span>]
    </span><span class="kw">pub fn </span>ZSTD_registerSequenceProducer(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        sequenceProducerState: <span class="kw-2">*mut </span>::core::ffi::c_void,
        sequenceProducer: ZSTD_sequenceProducer_F,
    );
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">"Buffer-less streaming compression (synchronous mode)\n\nA ZSTD_CCtx object is required to track streaming operations.\nUse ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.\nZSTD_CCtx object can be re-used multiple times within successive compression operations.\n\nStart by initializing a context.\nUse ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression.\n\nThen, consume your input using ZSTD_compressContinue().\nThere are some important considerations to keep in mind when using this advanced function :\n- ZSTD_compressContinue() has no internal buffer. It uses externally provided buffers only.\n- Interface is synchronous : input is consumed entirely and produces 1+ compressed blocks.\n- Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.\nWorst case evaluation is provided by ZSTD_compressBound().\nZSTD_compressContinue() doesn't guarantee recover after a failed compression.\n- ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).\nIt remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)\n- ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.\nIn which case, it will \"discard\" the relevant memory section from its history.\n\nFinish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.\nIt's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.\nWithout last block mark, frames are considered unfinished (hence corrupted) by compliant decoders.\n\n`ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress again."</span>]
    </span><span class="kw">pub fn </span>ZSTD_compressBegin(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressBegin_usingDict(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        compressionLevel: ::core::ffi::c_int,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressBegin_usingCDict(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_copyCCtx(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        preparedCCtx: <span class="kw-2">*const </span>ZSTD_CCtx,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressContinue(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressEnd(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressBegin_advanced(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
        params: ZSTD_parameters,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressBegin_usingCDict_advanced(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        cdict: <span class="kw-2">*const </span>ZSTD_CDict,
        fParams: ZSTD_frameParameters,
        pledgedSrcSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">"Buffer-less streaming decompression (synchronous mode)\n\nA ZSTD_DCtx object is required to track streaming operations.\nUse ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.\nA ZSTD_DCtx object can be re-used multiple times.\n\nFirst typical operation is to retrieve frame parameters, using ZSTD_getFrameHeader().\nFrame header is extracted from the beginning of compressed frame, so providing only the frame's beginning is enough.\nData fragment must be large enough to ensure successful decoding.\n`ZSTD_frameHeaderSize_max` bytes is guaranteed to always be large enough.\nresult  : 0 : successful decoding, the `ZSTD_frameHeader` structure is correctly filled.\n&gt;0 : `srcSize` is too small, please provide at least result bytes on next attempt.\nerrorCode, which can be tested using ZSTD_isError().\n\nIt fills a ZSTD_frameHeader structure with important information to correctly decode the frame,\nsuch as the dictionary ID, content size, or maximum back-reference distance (`windowSize`).\nNote that these values could be wrong, either because of data corruption, or because a 3rd party deliberately spoofs false information.\nAs a consequence, check that values remain within valid application range.\nFor example, do not allocate memory blindly, check that `windowSize` is within expectation.\nEach application can set its own limits, depending on local restrictions.\nFor extended interoperability, it is recommended to support `windowSize` of at least 8 MB.\n\nZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize` bytes.\nZSTD_decompressContinue() is very sensitive to contiguity,\nif 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,\nor that previous contiguous segment is large enough to properly handle maximum back-reference distance.\nThere are multiple ways to guarantee this condition.\n\nThe most memory efficient way is to use a round buffer of sufficient size.\nSufficient size is determined by invoking ZSTD_decodingBufferSize_min(),\nwhich can return an error code if required value is too large for current system (in 32-bits mode).\nIn a round buffer methodology, ZSTD_decompressContinue() decompresses each block next to previous one,\nup to the moment there is not enough room left in the buffer to guarantee decoding another full block,\nwhich maximum size is provided in `ZSTD_frameHeader` structure, field `blockSizeMax`.\nAt which point, decoding can resume from the beginning of the buffer.\nNote that already decoded data stored in the buffer should be flushed before being overwritten.\n\nThere are alternatives possible, for example using two or more buffers of size `windowSize` each, though they consume more memory.\n\nFinally, if you control the compression process, you can also ignore all buffer size rules,\nas long as the encoder and decoder progress in \"lock-step\",\naka use exactly the same buffer sizes, break contiguity at the same place, etc.\n\nOnce buffers are setup, start decompression, with ZSTD_decompressBegin().\nIf decompression requires a dictionary, use ZSTD_decompressBegin_usingDict() or ZSTD_decompressBegin_usingDDict().\n\nThen use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.\nZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().\nZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.\n\nresult of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily &lt;= dstCapacity).\nIt can be zero : it just means ZSTD_decompressContinue() has decoded some metadata item.\nIt can also be an error code, which can be tested with ZSTD_isError().\n\nA frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.\nContext can then be reset to start a new decompression.\n\nNote : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().\nThis information is not required to properly decode a frame.\n\n== Special case : skippable frames ==\n\nSkippable frames allow integration of user-defined data into a flow of concatenated frames.\nSkippable frames will be ignored (skipped) by decompressor.\nThe format of skippable frames is as follows :\na) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F\nb) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits\nc) Frame Content - any content (User Data) of length equal to Frame Size\nFor skippable frames ZSTD_getFrameHeader() returns zfhPtr-&gt;frameType==ZSTD_skippableFrame.\nFor skippable frames ZSTD_decompressContinue() always returns 0 : it only skips the content."</span>]
    </span><span class="kw">pub fn </span>ZSTD_decodingBufferSize_min(
        windowSize: ::core::ffi::c_ulonglong,
        frameContentSize: ::core::ffi::c_ulonglong,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_decompressBegin(dctx: <span class="kw-2">*mut </span>ZSTD_DCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_decompressBegin_usingDict(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dict: <span class="kw-2">*const </span>::core::ffi::c_void,
        dictSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_decompressBegin_usingDDict(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        ddict: <span class="kw-2">*const </span>ZSTD_DDict,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_nextSrcSizeToDecompress(dctx: <span class="kw-2">*mut </span>ZSTD_DCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_decompressContinue(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_copyDCtx(dctx: <span class="kw-2">*mut </span>ZSTD_DCtx, preparedDCtx: <span class="kw-2">*const </span>ZSTD_DCtx);
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_nextInputType_e {
    ZSTDnit_frameHeader = <span class="number">0</span>,
    ZSTDnit_blockHeader = <span class="number">1</span>,
    ZSTDnit_block = <span class="number">2</span>,
    ZSTDnit_lastBlock = <span class="number">3</span>,
    ZSTDnit_checksum = <span class="number">4</span>,
    ZSTDnit_skippableFrame = <span class="number">5</span>,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_nextInputType(dctx: <span class="kw-2">*mut </span>ZSTD_DCtx) -&gt; ZSTD_nextInputType_e;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">"This API is deprecated in favor of the regular compression API.\nYou can get the frame header down to 2 bytes by setting:\n- ZSTD_c_format = ZSTD_f_zstd1_magicless\n- ZSTD_c_contentSizeFlag = 0\n- ZSTD_c_checksumFlag = 0\n- ZSTD_c_dictIDFlag = 0\n\nThis API is not as well tested as our normal API, so we recommend not using it.\nWe will be removing it in a future version. If the normal API doesn't provide\nthe functionality you need, please open a GitHub issue.\n\nBlock functions produce and decode raw zstd blocks, without frame metadata.\nFrame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (&lt; 100 bytes).\nBut users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes.\n\nA few rules to respect :\n- Compressing and decompressing require a context structure\n+ Use ZSTD_createCCtx() and ZSTD_createDCtx()\n- It is necessary to init context before starting\n+ compression : any ZSTD_compressBegin*() variant, including with dictionary\n+ decompression : any ZSTD_decompressBegin*() variant, including with dictionary\n- Block size is limited, it must be &lt;= ZSTD_getBlockSize() &lt;= ZSTD_BLOCKSIZE_MAX == 128 KB\n+ If input is larger than a block size, it's necessary to split input data into multiple blocks\n+ For inputs larger than a single block, consider using regular ZSTD_compress() instead.\nFrame metadata is not that costly, and quickly becomes negligible as source size grows larger than a block.\n- When a block is considered not compressible enough, ZSTD_compressBlock() result will be 0 (zero) !\n===&gt; In which case, nothing is produced into `dst` !\n+ User __must__ test for such outcome and deal directly with uncompressed data\n+ A block cannot be declared incompressible if ZSTD_compressBlock() return value was != 0.\nDoing so would mess up with statistics history, leading to potential data corruption.\n+ ZSTD_decompressBlock() _doesn't accept uncompressed data as input_ !!\n+ In case of multiple successive blocks, should some of them be uncompressed,\ndecoder must be informed of their existence in order to follow proper history.\nUse ZSTD_insertBlock() for such a case."</span>]
    </span><span class="kw">pub fn </span>ZSTD_getBlockSize(cctx: <span class="kw-2">*const </span>ZSTD_CCtx) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_compressBlock(
        cctx: <span class="kw-2">*mut </span>ZSTD_CCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_decompressBlock(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        dst: <span class="kw-2">*mut </span>::core::ffi::c_void,
        dstCapacity: usize,
        src: <span class="kw-2">*const </span>::core::ffi::c_void,
        srcSize: usize,
    ) -&gt; usize;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_insertBlock(
        dctx: <span class="kw-2">*mut </span>ZSTD_DCtx,
        blockStart: <span class="kw-2">*const </span>::core::ffi::c_void,
        blockSize: usize,
    ) -&gt; usize;
}
<span class="attr">#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
</span><span class="kw">pub enum </span>ZSTD_ErrorCode {
    ZSTD_error_no_error = <span class="number">0</span>,
    ZSTD_error_GENERIC = <span class="number">1</span>,
    ZSTD_error_prefix_unknown = <span class="number">10</span>,
    ZSTD_error_version_unsupported = <span class="number">12</span>,
    ZSTD_error_frameParameter_unsupported = <span class="number">14</span>,
    ZSTD_error_frameParameter_windowTooLarge = <span class="number">16</span>,
    ZSTD_error_corruption_detected = <span class="number">20</span>,
    ZSTD_error_checksum_wrong = <span class="number">22</span>,
    ZSTD_error_literals_headerWrong = <span class="number">24</span>,
    ZSTD_error_dictionary_corrupted = <span class="number">30</span>,
    ZSTD_error_dictionary_wrong = <span class="number">32</span>,
    ZSTD_error_dictionaryCreation_failed = <span class="number">34</span>,
    ZSTD_error_parameter_unsupported = <span class="number">40</span>,
    ZSTD_error_parameter_combination_unsupported = <span class="number">41</span>,
    ZSTD_error_parameter_outOfBound = <span class="number">42</span>,
    ZSTD_error_tableLog_tooLarge = <span class="number">44</span>,
    ZSTD_error_maxSymbolValue_tooLarge = <span class="number">46</span>,
    ZSTD_error_maxSymbolValue_tooSmall = <span class="number">48</span>,
    ZSTD_error_stabilityCondition_notRespected = <span class="number">50</span>,
    ZSTD_error_stage_wrong = <span class="number">60</span>,
    ZSTD_error_init_missing = <span class="number">62</span>,
    ZSTD_error_memory_allocation = <span class="number">64</span>,
    ZSTD_error_workSpace_tooSmall = <span class="number">66</span>,
    ZSTD_error_dstSize_tooSmall = <span class="number">70</span>,
    ZSTD_error_srcSize_wrong = <span class="number">72</span>,
    ZSTD_error_dstBuffer_null = <span class="number">74</span>,
    ZSTD_error_noForwardProgress_destFull = <span class="number">80</span>,
    ZSTD_error_noForwardProgress_inputEmpty = <span class="number">82</span>,
    ZSTD_error_frameIndex_tooLarge = <span class="number">100</span>,
    ZSTD_error_seekableIO = <span class="number">102</span>,
    ZSTD_error_dstBuffer_wrong = <span class="number">104</span>,
    ZSTD_error_srcBuffer_wrong = <span class="number">105</span>,
    ZSTD_error_sequenceProducer_failed = <span class="number">106</span>,
    ZSTD_error_externalSequences_invalid = <span class="number">107</span>,
    ZSTD_error_maxCode = <span class="number">120</span>,
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="attr">#[doc = <span class="string">" ZSTD_getErrorCode() :\nconvert a `size_t` function result into a `ZSTD_ErrorCode` enum type,\nwhich can be used to compare with enum list published above"</span>]
    </span><span class="kw">pub fn </span>ZSTD_getErrorCode(functionResult: usize) -&gt; ZSTD_ErrorCode;
}
<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="kw">pub fn </span>ZSTD_getErrorString(
        code: ZSTD_ErrorCode,
    ) -&gt; <span class="kw-2">*const </span>::core::ffi::c_char;
}
</code></pre></div></section></main></body></html>